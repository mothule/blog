<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ja-JP"><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://blog.mothule.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.mothule.com/" rel="alternate" type="text/html" hreflang="ja-JP" /><updated>2020-05-18T20:02:26+09:00</updated><id>https://blog.mothule.com/feed.xml</id><title type="html">もちゅろぐ</title><subtitle>iOSやSwift,RubyやRailsなどiPhoneアプリ開発とサーバーサイド開発を中心に綴っている技術ブログ</subtitle><entry><title type="html">ln -sでシンボリックリンクを作る</title><link href="https://blog.mothule.com/tools/ln/tools-ln-guide" rel="alternate" type="text/html" title="ln -sでシンボリックリンクを作る" /><published>2020-05-18T00:00:00+09:00</published><updated>2020-05-18T20:02:14+09:00</updated><id>https://blog.mothule.com/tools/ln/tools-ln-guide</id><content type="html" xml:base="https://blog.mothule.com/tools/ln/tools-ln-guide">&lt;p&gt;Windowsでいうショートカットに似た何か。&lt;/p&gt;

&lt;h2 id=&quot;ln--sでシンボリックリンクを構築&quot;&gt;ln -sでシンボリックリンクを構築&lt;/h2&gt;

&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;ln -s リンク対象パス リンク作成先のディレクトリパス&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;自分の中で「リンク」ってワードが邪魔して&lt;br /&gt;
src/destどっちがどっちか分からなくなることが頻発する。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ln &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; ~/オレの/最強の/凄いコマンド /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;ls--lでシンボリックを確認&quot;&gt;ls -lでシンボリックを確認&lt;/h2&gt;

&lt;p&gt;シンボリックリンクはファイル名とリンク先が「&lt;code class=&quot;highlighter-rouge&quot;&gt;name -&amp;gt; original path&lt;/code&gt;」形式で表示されます。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ln &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; ~/オレの/最強の/凄いコマンド /usr/local/bin/
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; /usr/local/bin/
凄いコマンド -&amp;gt; ~/オレの/最強の/凄いコマンド
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;unlinkでシンボリックリンクを解除&quot;&gt;unlinkでシンボリックリンクを解除&lt;/h2&gt;

&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;unlink シンボリックのパス&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;unlink /usr/local/bin/使い物にならない自作コマンド
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;せめて&lt;code class=&quot;highlighter-rouge&quot;&gt;ln -d&lt;/code&gt;とかにしてほしかったな。&lt;/p&gt;</content><author><name></name></author><category term="tools" /><category term="ln" /><summary type="html">Windowsでいうショートカットに似た何か。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-18-tools-ln-guide/0.png" /></entry><entry><title type="html">ターミナルからRubyMineを起動、比較、マージなどする</title><link href="https://blog.mothule.com/tools/rubymine/tools-rubymine-launch-from-terminal" rel="alternate" type="text/html" title="ターミナルからRubyMineを起動、比較、マージなどする" /><published>2020-05-18T00:00:00+09:00</published><updated>2020-05-18T18:36:28+09:00</updated><id>https://blog.mothule.com/tools/rubymine/tools-rubymine-launch-from-terminal</id><content type="html" xml:base="https://blog.mothule.com/tools/rubymine/tools-rubymine-launch-from-terminal">&lt;p&gt;RubyMineは便利ですが、普段はターミナルを触ることが多いので、ターミナルからRubyMineを開く方法について調べたら、開く以外のことができることが分かったのでまとめます。&lt;/p&gt;

&lt;h2 id=&quot;ターミナルからrubymineで開く&quot;&gt;ターミナルからRubyMineで開く&lt;/h2&gt;

&lt;p&gt;まずターミナルからRubyMine.appwを開くには&lt;code class=&quot;highlighter-rouge&quot;&gt;open&lt;/code&gt;コマンドを使います。
最後のドットはそのフォルダをRubyMineで開くことを意味します。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;open &lt;span class=&quot;nt&quot;&gt;-na&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;RubyMine.app&quot;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;-a : アプリケーションを指定する&lt;/li&gt;
  &lt;li&gt;-n : アプリが起動済みでも新しいインスタンスで開く&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;シェルスクリプト化する&quot;&gt;シェルスクリプト化する&lt;/h2&gt;

&lt;h3 id=&quot;シェルスクリプトを用意&quot;&gt;シェルスクリプトを用意&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
open &lt;span class=&quot;nt&quot;&gt;-na&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;RubyMine.app&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--args&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$@&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;これを&lt;code class=&quot;highlighter-rouge&quot;&gt;rubymine&lt;/code&gt;という名前で保存します。&lt;/p&gt;

&lt;h3 id=&quot;実行権限付与&quot;&gt;実行権限付与&lt;/h3&gt;
&lt;p&gt;さっき作ったシェルスクリプトの実行権限を変更します&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;chmod 711 rubymine
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;これでターミナルからrubymineスクリプトを実行できるようになります。&lt;/p&gt;

&lt;h3 id=&quot;パスが見えるようにする&quot;&gt;パスが見えるようにする&lt;/h3&gt;

&lt;p&gt;このままだと配置した場所のパスが必要になるので、ターミナルが見えるようにパスが見える場所に配置します。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mv rubymine /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;なおこの場所でなくとも&lt;code class=&quot;highlighter-rouge&quot;&gt;cat $PATH&lt;/code&gt;で表示されるディレクトリ上にならどこでも構いません。&lt;/p&gt;

&lt;h3 id=&quot;rubymineに渡せる引数一覧&quot;&gt;RubyMineに渡せる引数一覧&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;引数なし : RubyMine起動&lt;/li&gt;
  &lt;li&gt;ファイルまたはディレクトリのパス : RubyMineで指定パスを開きます&lt;/li&gt;
  &lt;li&gt;diff : 渡された２つのファイルの差分を見ます&lt;/li&gt;
  &lt;li&gt;merge : 渡されたファイル2~3つと出力パスでマージします&lt;/li&gt;
  &lt;li&gt;format : 指定されたファイルにコードスタイルのフォーマットを適用します&lt;/li&gt;
  &lt;li&gt;inspect : 指定プロジェクトでコード検査します&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rubymineでファイル差分を見る&quot;&gt;RubyMineでファイル差分を見る&lt;/h2&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;rubymine diff &amp;lt;path1&amp;gt; &amp;lt;path2&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hoge&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; hoge.txt
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Fuga&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; fuga.txt
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rubymine diff hoge.txt fuga.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-18-tools-rubymine-launch-from-terminal/1.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-18-tools-rubymine-launch-from-terminal/1.png&quot; width=&quot;100%&quot; alt=&quot;RubyMine diff画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;rubymineでファイルマージする&quot;&gt;RubyMineでファイルマージする&lt;/h2&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;rubymine merge &amp;lt;path1&amp;gt; &amp;lt;path2&amp;gt; [&amp;lt;base&amp;gt;] &amp;lt;output&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hoge&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; hoge.txt
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Fuga&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; fuga.txt
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;touch base.txt
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;touch out.txt
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rubymine diff hoge.txt fuga.txt base.txt out.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-18-tools-rubymine-launch-from-terminal/2.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-18-tools-rubymine-launch-from-terminal/2.png&quot; width=&quot;100%&quot; alt=&quot;RubyMine merge画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;rubymineでファイルフォーマットを適用する&quot;&gt;RubyMineでファイルフォーマットを適用する&lt;/h2&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;rubymine format [&amp;lt;options&amp;gt;] &amp;lt;path ...&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;ruby.rb
def main
puts &lt;span class=&quot;s2&quot;&gt;&quot;hogehogehoge&quot;&lt;/span&gt;
end
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rubymine ruby.rb
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;ruby.rb
def main
  puts &lt;span class=&quot;s2&quot;&gt;&quot;hogehogehoge&quot;&lt;/span&gt;
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;どうやらrubocopが動くようではなく、RubyMine内の設定(Editor ｜ Code Style)に沿うようです。&lt;/p&gt;

&lt;h3 id=&quot;options&quot;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;-h : ヘルプ表示&lt;/li&gt;
  &lt;li&gt;-m or -mask : コンマ区切りでマスクファイルの一覧
    &lt;ul&gt;
      &lt;li&gt;例 : -m &lt;em&gt;.xml,&lt;/em&gt;.html&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;-r or -R : 階層処理&lt;/li&gt;
  &lt;li&gt;-s or -settings : ExportされたRubyMine内の設定&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rubymineでコード検査する&quot;&gt;RubyMineでコード検査する&lt;/h2&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;rubymine inspect &amp;lt;project&amp;gt; &amp;lt;inspection-profile&amp;gt; &amp;lt;output&amp;gt; [&amp;lt;options&amp;gt;]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;RubyMineでコード書いていると警告されるアレです。&lt;br /&gt;
ターミナル上からコード検査をして結果を外部ファイルに出力します。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/Downloads/sandbox&lt;/code&gt;ディレクトリがあり、その中に&lt;code class=&quot;highlighter-rouge&quot;&gt;ruby.rb&lt;/code&gt;ファイルがあった場合&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rubymine inspect ~/Downloads/sandbox/ ~/Downloads/sandbox/.idea/inspectionProfiles/Project_Default.xml ~/Downloads/sandbox/InspectionResults &lt;span class=&quot;nt&quot;&gt;-v2&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; ~/Downloads/sandbox/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;options-1&quot;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;-d : 検査ディレクトリの指定.&lt;/li&gt;
  &lt;li&gt;-format : 結果フォーマットの指定(xml/json/plan). デフォはxml&lt;/li&gt;
  &lt;li&gt;v : 検査詳細レベル
    &lt;ul&gt;
      &lt;li&gt;-v0 : デフォルト(最も低い)&lt;/li&gt;
      &lt;li&gt;-v1 : ミディオム&lt;/li&gt;
      &lt;li&gt;-v2 : 最大&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;diffとmergeがあるのは知りませんでした。&lt;br /&gt;
渡せる引数からしてgit mergetoolに登録できるかもしれません。&lt;br /&gt;
もし渡せたら重いp4mergeとはオサラバです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jetbrains.com/help/ruby/working-with-the-ide-features-from-command-line.html&quot;&gt;RubyMine - Command-line interface&lt;/a&gt;を参考にしてあります。
なお公式記事内では &lt;code class=&quot;highlighter-rouge&quot;&gt;inspect&lt;/code&gt; が &lt;code class=&quot;highlighter-rouge&quot;&gt;rinspect&lt;/code&gt; となっています。&lt;code class=&quot;highlighter-rouge&quot;&gt;rinspect&lt;/code&gt;では動かなかったので多分タイポです。&lt;/p&gt;</content><author><name></name></author><category term="tools" /><category term="rubymine" /><summary type="html">RubyMineは便利ですが、普段はターミナルを触ることが多いので、ターミナルからRubyMineを開く方法について調べたら、開く以外のことができることが分かったのでまとめます。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-18-tools-rubymine-launch-from-terminal/eyecatch.png" /></entry><entry><title type="html">CarthageのCartfileの書き方と個別更新方法</title><link href="https://blog.mothule.com/ios/carthage/ios-carthage-cartfile-format" rel="alternate" type="text/html" title="CarthageのCartfileの書き方と個別更新方法" /><published>2020-05-17T00:00:00+09:00</published><updated>2020-05-17T18:54:56+09:00</updated><id>https://blog.mothule.com/ios/carthage/ios-carthage-cartfile-format</id><content type="html" xml:base="https://blog.mothule.com/ios/carthage/ios-carthage-cartfile-format">&lt;p&gt;Podfileと書き方が微妙に異なるので注意です。カンマは使いません。&lt;/p&gt;

&lt;p&gt;ライブラリを導入したら新しいバージョンが公開されたら追従しなければいけません。
この記事ではCarthageで管理してるライブラリのバージョン追従方法について説明します。&lt;/p&gt;

&lt;h2 id=&quot;cartfileでバージョンを指定する&quot;&gt;Cartfileでバージョンを指定する&lt;/h2&gt;

&lt;p&gt;例えばCartfileでは次のようにライブラリのバージョンを指定することができます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;github &quot;SwiftyJSON&quot; ~&amp;gt; 4.2.0
github &quot;Hoge&quot; &amp;gt;= 4.2.0
github &quot;Fuga&quot; == 4.2.0
github &quot;Nuga&quot; &quot;develop&quot;
github &quot;Moga&quot; &quot;ab12c3ef4&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;それぞれ順に説明していきます。&lt;/p&gt;

&lt;h3 id=&quot;で範囲指定する&quot;&gt;~&amp;gt;で範囲指定する&lt;/h3&gt;
&lt;p&gt;最も多く使われてるであろう書き方です。
例えばバージョン履歴が下記だった場合で説明します。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;4.2.0&lt;/li&gt;
  &lt;li&gt;4.2.1&lt;/li&gt;
  &lt;li&gt;4.3.0&lt;/li&gt;
  &lt;li&gt;5.0.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このときにCartfileで&lt;code class=&quot;highlighter-rouge&quot;&gt;github &quot;Hoge&quot; ~&amp;gt; 4.2.0&lt;/code&gt;が記入された状態で&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt;を実行したら&lt;code class=&quot;highlighter-rouge&quot;&gt;4.2.1&lt;/code&gt;までアップデートします。&lt;br /&gt;
もし&lt;code class=&quot;highlighter-rouge&quot;&gt;github &quot;Hoge&quot; ~&amp;gt; 4.2&lt;/code&gt;が記入されてたら&lt;code class=&quot;highlighter-rouge&quot;&gt;4.3.0&lt;/code&gt;までアップデートします。&lt;/p&gt;

&lt;p&gt;なかなか範囲が覚えにくいと思いますが、最後の数字が&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;に置き換えて見れば分かりやすくなります。&lt;br /&gt;
例えば &lt;code class=&quot;highlighter-rouge&quot;&gt;github &quot;Hoge&quot; ~&amp;gt; 4.2.0&lt;/code&gt;であれば&lt;code class=&quot;highlighter-rouge&quot;&gt;4.2.x&lt;/code&gt;系です。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;4.2&lt;/code&gt;なら&lt;code class=&quot;highlighter-rouge&quot;&gt;4.x&lt;/code&gt;系です。つまり4系バージョンですね。&lt;/p&gt;

&lt;h3 id=&quot;-で指定バージョン以上&quot;&gt;&amp;gt;= で指定バージョン以上&lt;/h3&gt;

&lt;p&gt;指定バージョン値以上のバージョンを指定します。&lt;br /&gt;
Cartfileに&lt;code class=&quot;highlighter-rouge&quot;&gt;github &quot;Hoge&quot; &amp;gt;= 4.2.1&lt;/code&gt;と記入された状態で&lt;br /&gt;
バージョン履歴が下記だった場合は、&lt;code class=&quot;highlighter-rouge&quot;&gt;5.0.0&lt;/code&gt;がインストールされます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;4.2.0&lt;/li&gt;
  &lt;li&gt;4.2.1&lt;/li&gt;
  &lt;li&gt;4.3.0&lt;/li&gt;
  &lt;li&gt;5.0.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この書き方は少し破壊変更リスクが伴うため使う側としてはオススメしないです。&lt;br /&gt;
こっちよりも前述した範囲指定のほうが安全性をそれなりに維持できます。&lt;/p&gt;

&lt;h3 id=&quot;-で指定バージョンのみ&quot;&gt;== で指定バージョンのみ&lt;/h3&gt;

&lt;p&gt;もっとも安全なバージョン指定方法です。&lt;br /&gt;
Cartfileに&lt;code class=&quot;highlighter-rouge&quot;&gt;github &quot;Hoge&quot; == 4.2.1&lt;/code&gt;と記入されていたら&lt;br /&gt;
他にバージョンが出ていても &lt;code class=&quot;highlighter-rouge&quot;&gt;4.2.1&lt;/code&gt;しかインストールされません。&lt;/p&gt;

&lt;p&gt;丁寧にバージョンアップをしたいライブラリや開発運用に適した方法です。&lt;/p&gt;

&lt;h3 id=&quot;revisionでコミット指定&quot;&gt;revisionでコミット指定&lt;/h3&gt;

&lt;p&gt;GitHub上のコミットを名指しでインストールします。コミットで発行されているrevisionを使います。&lt;br /&gt;
またrevisionだけでなくブランチ名でも使えます。&lt;/p&gt;

&lt;p&gt;使っていたライブラリに不具合や脆弱性、iOS最新版が出たけどライブラリ側がバージョンを切っていない状態など&lt;br /&gt;
緊急時で使うことがあるので覚えておいたほうがいいです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Carthage/Carthage/blob/master/Documentation/Artifacts.md#version-requirement&quot;&gt;Carthage公式のVersion requirement&lt;/a&gt;でも英語ですが説明セクションはあります。&lt;/p&gt;

&lt;h2 id=&quot;ライブラリの個別更新&quot;&gt;ライブラリの個別更新&lt;/h2&gt;
&lt;p&gt;更新したいライブラリをCartfileに書いて&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;を実行すると、更新不要なライブラリも更新対象となります。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthge update&lt;/code&gt;ではライブラリ名を渡せばそのライブラリのみを更新してくれます。
SwiftyJSONのみを更新する場合&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;carthage update SwiftyJSON &lt;span class=&quot;nt&quot;&gt;--platform&lt;/span&gt; iOS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;ビルド済みライブラリのスキップ&quot;&gt;ビルド済みライブラリのスキップ&lt;/h2&gt;
&lt;p&gt;先程と同じテーマですが、&lt;code class=&quot;highlighter-rouge&quot;&gt;--cache-builds&lt;/code&gt;オプションを渡すことでビルド済みのライブラリの場合はスキップしてくれます。
この場合は個別でライブラリ名を指定は必要ありません。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;carthage update &lt;span class=&quot;nt&quot;&gt;--platform&lt;/span&gt; iOS &lt;span class=&quot;nt&quot;&gt;--cache-builds&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;もっと体系的に理解する&quot;&gt;もっと体系的に理解する&lt;/h2&gt;

&lt;p&gt;この記事では、記事の読みやすいよう導入に絞ってます。
もしチーム運用、git管理、CocoaPodsとの違いなど使い続けたら必要になる部分は別記事に分けており、&lt;br /&gt;
「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage&quot;&gt;Carthageの使い方を体系的に理解する&lt;/a&gt;&lt;/span&gt;
」からまとめて知ることができます。&lt;/p&gt;</content><author><name></name></author><category term="ios" /><category term="carthage" /><summary type="html">Podfileと書き方が微妙に異なるので注意です。カンマは使いません。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-17-ios-carthage-cartfile-format/0.png" /></entry><entry><title type="html">Carthage bootstrapとGit管理をチーム運用観点で整理</title><link href="https://blog.mothule.com/ios/carthage/ios-carthage-team-collaboration" rel="alternate" type="text/html" title="Carthage bootstrapとGit管理をチーム運用観点で整理" /><published>2020-05-15T00:00:00+09:00</published><updated>2020-05-17T18:54:56+09:00</updated><id>https://blog.mothule.com/ios/carthage/ios-carthage-team-collaboration</id><content type="html" xml:base="https://blog.mothule.com/ios/carthage/ios-carthage-team-collaboration">&lt;p&gt;この記事ではcarthage bootstrapとは何か？Git管理はどうするか？をチーム運用観点でこれら関係性を整理します。&lt;/p&gt;

&lt;h2 id=&quot;carthage-updateとbootstrapの違い&quot;&gt;carthage updateとbootstrapの違い&lt;/h2&gt;
&lt;p&gt;carthage bootstrapについて説明します。&lt;/p&gt;

&lt;p&gt;説明には、carthage bootstrapと比較するコマンドや関係するファイルを用いて説明します。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;carthage updateは&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile&lt;/code&gt;を見てframeworkと&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile.resolved&lt;/code&gt;を作成する&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile.resolved&lt;/code&gt;は実際に作成したframeworkの&lt;code class=&quot;highlighter-rouge&quot;&gt;ライブラリ&lt;/code&gt;と&lt;code class=&quot;highlighter-rouge&quot;&gt;バージョン&lt;/code&gt;が記載されてる&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage bootstrap&lt;/code&gt;は&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile.resolved&lt;/code&gt;を見てframeworkを作成する&lt;/li&gt;
  &lt;li&gt;carthage updateは&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile&lt;/code&gt;を見て&lt;strong&gt;なるべく最新&lt;/strong&gt;のライブラリバージョンを選ぶ&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1、2、3をイメージで説明します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-15-ios-carthage-team-collaboration/1.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-15-ios-carthage-team-collaboration/1.png&quot; width=&quot;100%&quot; alt=&quot;Carthageのupdateとbootstrapの違い&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;carthage updateはCartfileを使ってCartfile.resolvedとフレームワークを更新します。&lt;/li&gt;
  &lt;li&gt;carthage bootstrapはCartfile.resolvedを使ってフレームワークを更新します。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そして最も大きな違いは、&lt;strong&gt;carthage updateには冪等性がなく、carthage bootstrapには冪等性がある点です。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;carthage-updateの動き&quot;&gt;carthage updateの動き&lt;/h3&gt;
&lt;p&gt;例えば、carthage updateを5月1日に実行して、SwiftyJSON ver4のframeworkが作成されます。&lt;br /&gt;
半月後にSwiftyJSONが新しいバージョンver5をリリースします。&lt;br /&gt;
更に&lt;strong&gt;半月後にもう一度carthage updateを実行すると、SwiftyJSON ver5のframeworkが作成されます。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-15-ios-carthage-team-collaboration/2.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-15-ios-carthage-team-collaboration/2.png&quot; width=&quot;100%&quot; alt=&quot;Carthage updateの動き&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;つまり、&lt;strong&gt;carthage updateはライブラリ更新をします。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;carthage-bootstrapの動き&quot;&gt;carthage bootstrapの動き&lt;/h3&gt;
&lt;p&gt;updateではなくbootstrapですると、&lt;br /&gt;
1ヶ月後でもframeworkのバージョンは変わりません。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-15-ios-carthage-team-collaboration/3.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-15-ios-carthage-team-collaboration/3.png&quot; width=&quot;100%&quot; alt=&quot;Carthage updateの動き&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;つまり、&lt;strong&gt;carthage updateは環境を再現します。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;carthage-updateとbootstrapの使い分け&quot;&gt;carthage updateとbootstrapの使い分け&lt;/h3&gt;

&lt;p&gt;ライブラリの新規・更新はupdate、環境構築はbootstrapとして使います。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;updateを使うケース
    &lt;ul&gt;
      &lt;li&gt;ライブラリを追加する&lt;/li&gt;
      &lt;li&gt;ライブラリのバージョンを上げる&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;bootstrapを使うケース
    &lt;ul&gt;
      &lt;li&gt;新しくチームメンバーが入ってきて、開発環境を構築する&lt;/li&gt;
      &lt;li&gt;別メンバーがライブラリのバージョンを更新した&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;carthageとgit管理&quot;&gt;CarthageとGit管理&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;で&lt;code class=&quot;highlighter-rouge&quot;&gt;Carghage&lt;/code&gt;ディレクトリと&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage.resolved&lt;/code&gt;ファイルが生成されますが、&lt;br /&gt;
これらはGit管理下に加えるべきでしょうか？除外すべきでしょうか？&lt;/p&gt;

&lt;p&gt;方法は2つあります。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile.resolved&lt;/code&gt;だけをGit管理下において、&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage bootstrap&lt;/code&gt;で&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage&lt;/code&gt;ディレクトリを再現する方法と、&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile.resolved&lt;/code&gt;と&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage&lt;/code&gt;ディレクトリの両方をGit管理下においてgit cloneだけで再現環境を実現する方法です。&lt;/p&gt;

&lt;h3 id=&quot;cartfileresolvedのみをgit管理下にする&quot;&gt;Cartfile.resolvedのみをGit管理下にする&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile.resolved&lt;/code&gt;はライブラリ名とそれらのバージョンが記載されたファイルであることは説明しました。&lt;br /&gt;
しかし&lt;code class=&quot;highlighter-rouge&quot;&gt;framework&lt;/code&gt;はないので、&lt;code class=&quot;highlighter-rouge&quot;&gt;carthge bootstrap&lt;/code&gt;コマンドを使って必要なframeworkを構築します。&lt;/p&gt;

&lt;h3 id=&quot;cartfileresolvedとcarthageディレクトリ&quot;&gt;Cartfile.resolvedとCarthageディレクトリ&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile.resolved&lt;/code&gt;は他環境で再現をする上で必要です。&lt;br /&gt;
そこに加えて、&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage&lt;/code&gt;ディレクトリがあることで、frameworkの生成が不要になります。&lt;/p&gt;

&lt;h4 id=&quot;buildのみにする&quot;&gt;Buildのみにする&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage&lt;/code&gt;ディレクトリ全てをGit管理下不要です。&lt;br /&gt;
必要なのは生成済みframeworkなのため、&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage/Build&lt;/code&gt;ディレクトリのみで問題ありません。&lt;/p&gt;

&lt;p&gt;そのため&lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt;に追記が必要です。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Carthage/Checkouts
!Carthage/Build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;どちらがいいのか&quot;&gt;どちらがいいのか？&lt;/h3&gt;
&lt;p&gt;これは議論されているので、どちらがいいのか確定的なものはありません。&lt;br /&gt;
答えとしては案件によります。&lt;br /&gt;
なのでネットで「こちらがいい」と書いてあっても鵜呑みは危険です。&lt;br /&gt;
理由を見てそれが自分が適用しようとしてる条件に一致しているか判断することを進めます。&lt;/p&gt;

&lt;p&gt;ここではそれぞれのメリット・デメリットを部分的に抜粋します。&lt;br /&gt;
公平にするため、私情は入れず事実のみを載せます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cartfile.resolvedのみ
    &lt;ul&gt;
      &lt;li&gt;CIで毎回bootstrapでframework作成が必要&lt;/li&gt;
      &lt;li&gt;bootstrapが失敗するリスクがある&lt;/li&gt;
      &lt;li&gt;ライブラリ更新済みと未更新ブランチをまたぐとbootstrapが必要&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Cartfile.resolvedとCarthage
    &lt;ul&gt;
      &lt;li&gt;Swift versionを変更すると再生成が必要&lt;/li&gt;
      &lt;li&gt;Pull Requestでdiffが増える&lt;/li&gt;
      &lt;li&gt;git cloneが遅くなる&lt;/li&gt;
      &lt;li&gt;1ファイル100MBがあるとプッシュできない&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;swift-versionを変更すると再生成が必要&quot;&gt;Swift versionを変更すると再生成が必要&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Module Stability&lt;/code&gt;の有効になっていないライブラリでは、Swiftのバージョンを上げるたびにframeworkの再生成が必要です。&lt;/p&gt;

&lt;h3 id=&quot;ライブラリ更新後はbootstrapが必要&quot;&gt;ライブラリ更新後はbootstrapが必要&lt;/h3&gt;
&lt;p&gt;別メンバーがライブラリを更新したブランチをマージさせたら、&lt;br /&gt;
bootstrapでframework再生成が必要です。&lt;/p&gt;

&lt;h4 id=&quot;pull-requestでdiffが増える&quot;&gt;Pull Requestでdiffが増える&lt;/h4&gt;
&lt;p&gt;frameworkは1つのファイルではなくディレクトリになっており、中にファイルやディレクトリがあります。&lt;br /&gt;
そのファイル数だけGit管理となるため、frameworkを追加や変更したときのdiffは量が増えます。&lt;/p&gt;

&lt;h4 id=&quot;ciで毎回bootstrapでframework作成が必要&quot;&gt;CIで毎回bootstrapでframework作成が必要&lt;/h4&gt;
&lt;p&gt;CIなど新規環境下で環境構築をする場合は、bootstrapを実行してframeworkを生成する必要があります。&lt;br /&gt;
当然ですが、その分CI時間はかかります。&lt;/p&gt;

&lt;h4 id=&quot;bootstrapが失敗するリスクがある&quot;&gt;bootstrapが失敗するリスクがある&lt;/h4&gt;
&lt;p&gt;Carthageはxcodebuildでframeworkを生成しています。&lt;br /&gt;
可能性は低いのですが、私の環境でも何度か起きており、xcodebuildのバージョン差異や他要因で失敗することがあります。&lt;/p&gt;

&lt;p&gt;つまりそれは最悪Git管理下の情報だけでは環境再現が不可能となります。&lt;/p&gt;

&lt;h4 id=&quot;git-cloneが遅くなる&quot;&gt;git cloneが遅くなる&lt;/h4&gt;
&lt;p&gt;frameworkに関するファイル数が増える分、ファイル数やデータ数は増えるのでそれだけclone時やpull/fecthでのダウンロード時間は増えます。&lt;/p&gt;

&lt;h4 id=&quot;1ファイル100mbがあるとプッシュできない&quot;&gt;1ファイル100MBがあるとプッシュできない&lt;/h4&gt;
&lt;p&gt;GitHubでは1ファイル100MB以上のファイルコミットはできない制限が設けられており、LFSの設定が必要になります。&lt;/p&gt;

&lt;h2 id=&quot;私のチーム運用観点&quot;&gt;私のチーム運用観点&lt;/h2&gt;

&lt;p&gt;私が過去に経験してきたチームでのCarthage運用は次の通りです。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage/Build&lt;/code&gt;ディレクトリはコミットしない&lt;/li&gt;
  &lt;li&gt;Swiftバージョン更新時は、別ブランチからPull Request通す&lt;/li&gt;
  &lt;li&gt;Cartfileではバージョン指定してる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そして下記はそれぞれのメリット・デメリットに対する考えです。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Swift versionを変更すると再生成が必要
    &lt;ul&gt;
      &lt;li&gt;バージョン上がる度毎回変更してます&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ライブラリ更新後はbootstrapが必要
    &lt;ul&gt;
      &lt;li&gt;不要です。しかしGitからの取得量は増えます。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pull Requestでdiffが増える
    &lt;ul&gt;
      &lt;li&gt;バージョンを上げるだけのブランチなのでそもそもそのdiffを殆ど見ないです&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CIで毎回bootstrapでframework作成が必要
    &lt;ul&gt;
      &lt;li&gt;これはコミットしてるので不要です&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;bootstrapが失敗するリスクがある
    &lt;ul&gt;
      &lt;li&gt;バージョン固定してるので&lt;code class=&quot;highlighter-rouge&quot;&gt;bootstrap&lt;/code&gt;を使ってないです&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;git cloneが遅くなる
    &lt;ul&gt;
      &lt;li&gt;使っているfrmaeworkは10個ですが、それぞれのサイズは大きくはないので気になるほどになってないです&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;1ファイル100MBがあると運用不可能
    &lt;ul&gt;
      &lt;li&gt;使ってるframeworkに1ファイル100MBを超えるものはありません。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;バージョン上がるたびに全てのframework生成は時間がかかります。&lt;br /&gt;
それ以上に回数的にCIにかかる時間が増えます。&lt;br /&gt;
CIにキャッシュ仕込むのもありますが、CIが限定されますし、そのために開発環境が多少複雑にはなります。&lt;br /&gt;
git cloneが時間かかるとありますが、git cloneよりbootstrapの方が遥かに時間がかかります。&lt;br /&gt;
そして昔のCocoaPodsのように再現性がなくなることのリスクも気になります。&lt;/p&gt;

&lt;p&gt;なおこれは私の経験した案件にフィットした運用ですので鵜呑みにせず参考にしてください。&lt;/p&gt;

&lt;h2 id=&quot;もっと体系的に理解する&quot;&gt;もっと体系的に理解する&lt;/h2&gt;
&lt;p&gt;この記事では、記事の読みやすいよう導入に絞ってます。
もしCartfileの書き方や個別更新、インストール手順、CocoaPodsとの違いなど使い続けたら必要になる部分は別記事に分けており、&lt;br /&gt;
「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage&quot;&gt;Carthageの使い方を体系的に理解する&lt;/a&gt;&lt;/span&gt;
」からまとめて知ることができます。&lt;/p&gt;</content><author><name></name></author><category term="ios" /><category term="carthage" /><summary type="html">この記事ではcarthage bootstrapとは何か？Git管理はどうするか？をチーム運用観点でこれら関係性を整理します。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-15-ios-carthage-team-collaboration/0.png" /></entry><entry><title type="html">CarthageとCocoaPodsの違いを経験交えて比較する</title><link href="https://blog.mothule.com/ios/ios-carthage-vs-cocoapods" rel="alternate" type="text/html" title="CarthageとCocoaPodsの違いを経験交えて比較する" /><published>2020-05-14T00:00:00+09:00</published><updated>2020-05-17T22:15:34+09:00</updated><id>https://blog.mothule.com/ios/ios-carthage-vs-cocoapods</id><content type="html" xml:base="https://blog.mothule.com/ios/ios-carthage-vs-cocoapods">&lt;p&gt;CarthageとCocoaPodsの違いは「手軽」か「柔軟」かです。&lt;/p&gt;

&lt;h2 id=&quot;carthageとcocoapodsそれぞれの特徴&quot;&gt;CarthageとCocoaPodsそれぞれの特徴&lt;/h2&gt;

&lt;h3 id=&quot;共通点&quot;&gt;共通点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CocoaPodsならPodfile、CarthageならCartfileと管理ファイルに書かれたライブラリ情報からframeworkを作成します。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cocoapods&quot;&gt;CocoaPods&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;作成したframeworkのリンキングの自動設定&lt;/li&gt;
  &lt;li&gt;Xcodeワークスペース(.xcworkspace)を自動作成および更新&lt;/li&gt;
  &lt;li&gt;一元管理されたエコシステムでライブラリの発見率を向上させる
    &lt;ul&gt;
      &lt;li&gt;単一障害点となる&lt;/li&gt;
      &lt;li&gt;メンテナンス必要&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Xcode構造仕様に依存する&lt;/li&gt;
  &lt;li&gt;ライブラリ側の依存関係や構築方法を指定したpodspecファイルが必要&lt;/li&gt;
  &lt;li&gt;複雑しかし高機能&lt;/li&gt;
  &lt;li&gt;Podsプロジェクトと呼ばれるライブラリ集約プロジェクトからframeworkを作成&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;ライブラリの管理責任を一手に引き受け「使いやすい」をアプローチ&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;carthage&quot;&gt;Carthage&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;作成したframeworkのリンキングは手動設定&lt;/li&gt;
  &lt;li&gt;Xcodeワークスペース(.xcworkspace)やプロジェクト(.xcodeproj)に手を加えない&lt;/li&gt;
  &lt;li&gt;Carthage対応ライブラリは一元管理されておらずGitHubなどのトレンドページや個人の周知活動に依存する
    &lt;ul&gt;
      &lt;li&gt;一元管理システムがないのでその分のメンテナンス不要&lt;/li&gt;
      &lt;li&gt;単一障害点を回避できる※&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Xcode構造仕様の影響受けない&lt;/li&gt;
  &lt;li&gt;ライブラリ側はXcodeプロジェクトが必要&lt;/li&gt;
  &lt;li&gt;手間しかしシンプル&lt;/li&gt;
  &lt;li&gt;事前にframeworkを作成&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;余計な影響範囲を最小限に抑え「単純かつ柔軟」をアプローチ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;※Carthageのシステム自体は単一障害点はないですが、運用において実質スタンダードになっているGitホスティングサービスがGitHub一強となっていることから、GitHubが単一障害点になっていると思います。&lt;/p&gt;

&lt;h2 id=&quot;carthageとcocoapodsの各ライブラリ管理方法&quot;&gt;CarthageとCocoaPodsの各ライブラリ管理方法&lt;/h2&gt;

&lt;h3 id=&quot;cocoapods-1&quot;&gt;CocoaPods&lt;/h3&gt;

&lt;p&gt;CocoaPodsは&lt;code class=&quot;highlighter-rouge&quot;&gt;$ pod install&lt;/code&gt;でライブラリをインストールすると、&lt;br /&gt;
対象プロジェクトに対してワークスペース(.xcworkspace)を作成をしたり、&lt;br /&gt;
プロジェクトに対してオプション更新をしたりと、導入が楽になっているかわりに高機能となっています。&lt;/p&gt;

&lt;p&gt;作成されたワークスペースには、対象プロジェクトとは別に&lt;br /&gt;
Podsプロジェクト(Pods.xcodeproj)が作成されており、&lt;br /&gt;
その中にライブラリとなるソースコードが含まれています。&lt;/p&gt;

&lt;p&gt;ビルド実行することでPodsプロジェクト内のソースコードも一緒にビルドされて、&lt;br /&gt;
対象プロジェクトにはフレームワークとしてリンクされます。&lt;/p&gt;

&lt;p&gt;リンク処理も全てCocoaPodsが自動で行ってくれます。&lt;/p&gt;

&lt;h3 id=&quot;carthage-1&quot;&gt;Carthage&lt;/h3&gt;

&lt;p&gt;Carthageは最低限のライブラリからフレームワークの作成・更新のみとなります。&lt;br /&gt;
ワークスペースを作成したり、フレームワークをプロジェクトにリンクはしません。&lt;br /&gt;
プロジェクトへのフレームワーク追加は、自分で行う必要があります。&lt;/p&gt;

&lt;p&gt;詳しくは「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage-install-guide&quot;&gt;iOSのCarthage導入手順と注意点&lt;/a&gt;&lt;/span&gt;
」にまとめてあります。&lt;/p&gt;

&lt;h2 id=&quot;carthageとcocoapodsのメリットデメリット&quot;&gt;CarthageとCocoaPodsのメリット・デメリット&lt;/h2&gt;

&lt;p&gt;Carghageのメリットはビルドが早いだけでなく、安定していることだと思います。&lt;br /&gt;
CocoaPodsはとにかく楽です。&lt;/p&gt;

&lt;h3 id=&quot;環境構築速度&quot;&gt;環境構築速度&lt;/h3&gt;
&lt;p&gt;Carthage/CocoaPodsそれぞれの導入コストです。&lt;/p&gt;

&lt;p&gt;これはずば抜けてCocoaPodsに軍配が上がります。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;pod init&lt;/code&gt;でPodfileを作成し、内部にライブラリ名を記入後、&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install&lt;/code&gt;するだけで終わりです。
あとは生成されたワークスペースを開くだけでライブラリが使える環境になっています。&lt;/p&gt;

&lt;h3 id=&quot;ビルド時間の短縮&quot;&gt;ビルド時間の短縮&lt;/h3&gt;
&lt;p&gt;コンパイルとリンクなどビルド時間です。&lt;/p&gt;

&lt;p&gt;Carthageの勝ちです。
CocoaPodsと異なり一度frameworkを作成すれば、&lt;br /&gt;
以降はXcodeプロジェクト上でReBuildしても、&lt;br /&gt;
framework側でコンパイルが走ることはありません。&lt;/p&gt;

&lt;h4 id=&quot;速度差を測定してみる&quot;&gt;速度差を測定してみる&lt;/h4&gt;
&lt;p&gt;それぞれのビルド時間を測定してみました。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;測定は最初の5回は慣らし、5回目から数回測定。&lt;/li&gt;
  &lt;li&gt;測定ではRebuild(Clean+Build)で測定する。&lt;/li&gt;
  &lt;li&gt;インストールライブラリはSwiftJSON。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;環境&lt;/th&gt;
      &lt;th&gt;min&lt;/th&gt;
      &lt;th&gt;max&lt;/th&gt;
      &lt;th&gt;avg&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;CocoaPods&lt;/td&gt;
      &lt;td&gt;3.208s&lt;/td&gt;
      &lt;td&gt;3.492s&lt;/td&gt;
      &lt;td&gt;3.308s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Carthage&lt;/td&gt;
      &lt;td&gt;1.478s&lt;/td&gt;
      &lt;td&gt;1.765s&lt;/td&gt;
      &lt;td&gt;1.60725s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;vanilla&lt;/td&gt;
      &lt;td&gt;0.932s&lt;/td&gt;
      &lt;td&gt;1.143s&lt;/td&gt;
      &lt;td&gt;1.04967s&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;効果としては期待どおりで、ビルド時間短縮を目的とするには、十分効果があると見てよいと思います。&lt;/p&gt;

&lt;h3 id=&quot;xcodeの内部仕様の変更&quot;&gt;Xcodeの内部仕様の変更&lt;/h3&gt;
&lt;p&gt;Xcodeはバージョンが上がると、プロジェクトやワークスペースを表すxmlの構造が変わるケースがあります。&lt;/p&gt;

&lt;p&gt;そしてCocoaPodsはワークスペースやPodsプロジェクトの生成、リンクなど広範囲のXcodeの内部仕様を利用してます。&lt;br /&gt;
そのためXcodeバージョンアップ時に仕様と挙動が噛み合わず動かなくなることもあります。&lt;br /&gt;
この場合、CocoaPodsが対応してくれるまで待ったあとにバージョンを上げる必要があります。&lt;/p&gt;

&lt;p&gt;その点Carthageはフレームワークを作成するだけなので、Xcodeの内部仕様の影響は受けません。&lt;br /&gt;
ライブラリ側はXcodeプロジェクトを必要としますが、これはXcodeアプリから弄るもののため、内部仕様が変わってもXcodeアプリも変わるので影響を受けないです。&lt;/p&gt;

&lt;p&gt;そのため開発安定性はCocoaPodsより勝っているとも言えます。&lt;br /&gt;
CocoaPodsは毎年Xcodeのメジャーバージョンアップで心配になります。&lt;/p&gt;

&lt;h3 id=&quot;対応ライブラリ数&quot;&gt;対応ライブラリ数&lt;/h3&gt;
&lt;p&gt;これは具体的な数値を確かめる方法がCarthage側にはないのですが、体感としてはCocoaPodsの方が多く感じます。
ライブラリを使いたい時にCocoaPodsしか対応していない場面にいくつか出くわしているためです。&lt;/p&gt;

&lt;h2 id=&quot;cocoapodsの昔の話&quot;&gt;CocoaPodsの昔の話&lt;/h2&gt;

&lt;h3 id=&quot;今よりも酷いバグだらけのxcode&quot;&gt;今よりも酷いバグだらけのXcode&lt;/h3&gt;
&lt;p&gt;私はiOSとは2012年から関わっております。&lt;br /&gt;
その頃のXcodeは非常に不安定でバグも多く同じ操作でも正しく動かないとか普通でした。&lt;br /&gt;
Subversion登録ウィザードとか横ページングでステップ表現をしていたが、一度戻ってまた進むと、UIが消えるバグがあったり。&lt;/p&gt;

&lt;h3 id=&quot;cocoapodsが不安定で肝を冷やした話&quot;&gt;CocoaPodsが不安定で肝を冷やした話&lt;/h3&gt;
&lt;p&gt;CocoaPodsも再構築が失敗するのでソースコードだけでは復元が不可能なケースが稀にあり、&lt;br /&gt;
そのため実務ではリリース毎にPodsファイル含めたワークスペース内全てを圧縮したzipファイルを別途バックアップ管理せざる得ない状況でした。&lt;br /&gt;
「そんなことはない。大げさだ」と思う方は運が良かっただけだと思います。&lt;br /&gt;
Xcodeのバージョン、Rubyバージョン、CocoaPodsバージョン、クラッシュによる過去アプリプロジェクトの復元など色々な条件が重なって私のところでは発生し肝を冷やしました。
その時は昔からメンバーの一人が昔からMacを触ってる人がいて、その人はリリース毎のバージョンをzipでローカルでbackupしていたので助かったのですが。&lt;/p&gt;

&lt;h3 id=&quot;carthageの登場&quot;&gt;Carthageの登場&lt;/h3&gt;
&lt;p&gt;Carthageがよく目にするようになったのはiOS7あたりだったと思います。  &lt;br /&gt;
Xcodeのバージョンを上げたらCocoaPodsのpod installが失敗するようになり、開発が止まってしまうことがありました。&lt;br /&gt;
そのときにCarthageはフレームワークを事前に用意しておき、Xcodeに追加するだけで動くので、&lt;br /&gt;
Xcodeの仕様変更に影響をうけることがなく開発ができることが魅力的でした。&lt;/p&gt;

&lt;p&gt;当時、私はビルド時間短縮よりも、Xcodeに引きづられるCocoaPodsの不安定から開放されことが、メリットだと感じていました。（全てのライブラリがCarthage対応してないので開放はされないのですが…w）&lt;/p&gt;

&lt;p&gt;昔からXcodeやCocoaPodsを使っている人は、過去の経験からXcodeのバージョンアップやCocoaPodsのバージョンアップには慎重な方が多そうな気がします。&lt;/p&gt;

&lt;h2 id=&quot;carthageとcocoapodsどちらがいいか&quot;&gt;CarthageとCocoaPodsどちらがいいか&lt;/h2&gt;
&lt;p&gt;現時点ではどちらがいいとはいえないです。
Carthage一択でいきたい人がいたとしても、CocoaPodsでしか対応してないライブラリがあるのが事実です。&lt;/p&gt;

&lt;p&gt;またケースによっても変わってくると思います。
何かライブラリの調査をしたい場合に新しく調査用プロジェクトを作る場合とかであれば、CocoaPodsのほうが楽だと思います。&lt;/p&gt;

&lt;p&gt;現実解は、共存だと思います。&lt;/p&gt;

&lt;h2 id=&quot;もっと体系的に理解する&quot;&gt;もっと体系的に理解する&lt;/h2&gt;
&lt;p&gt;この記事では、記事の読みやすいよう導入に絞ってます。
もしCartfileの書き方や個別更新、チーム運用、git管理など使い続けたら必要になる部分は別記事に分けており、&lt;br /&gt;
「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage&quot;&gt;Carthageの使い方を体系的に理解する&lt;/a&gt;&lt;/span&gt;
」からまとめて知ることができます。&lt;/p&gt;</content><author><name></name></author><category term="ios" /><category term="carthage" /><category term="cocoapods" /><summary type="html">CarthageとCocoaPodsの違いは「手軽」か「柔軟」かです。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-14-ios-carthage-vs-cocoapods/0.png" /></entry><entry><title type="html">iOSのCarthage導入手順と注意点</title><link href="https://blog.mothule.com/ios/carthage/ios-carthage-install-guide" rel="alternate" type="text/html" title="iOSのCarthage導入手順と注意点" /><published>2020-05-14T00:00:00+09:00</published><updated>2020-05-17T18:54:56+09:00</updated><id>https://blog.mothule.com/ios/carthage/ios-carthage-install-guide</id><content type="html" xml:base="https://blog.mothule.com/ios/carthage/ios-carthage-install-guide">&lt;p&gt;Carthageの導入はちょっとした漏れでエラーにハマります。&lt;/p&gt;

&lt;p&gt;この記事は、iOSアプリにCarthage環境を導入する手順について説明します。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;MacにCarghageをインストールする&lt;/li&gt;
  &lt;li&gt;Cartfileにライブラリを記入&lt;/li&gt;
  &lt;li&gt;Cartfileからframework作成&lt;/li&gt;
  &lt;li&gt;プロジェクトにframeworkをリンク&lt;/li&gt;
  &lt;li&gt;ビルドフェイズにframeworkのコピースクリプトを作成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;なお、チーム運用、git管理、ライブラリのバージョン運用など詳細は、&lt;br /&gt;
「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage&quot;&gt;Carthageの使い方を体系的に理解する&lt;/a&gt;&lt;/span&gt;
」からまとめて知ることができます。&lt;/p&gt;

&lt;h2 id=&quot;macにcarghageをインストールする&quot;&gt;MacにCarghageをインストールする&lt;/h2&gt;

&lt;p&gt;CarthageはHomebrewでインストールできます。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew install carthage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;cartfileにライブラリを記入&quot;&gt;Cartfileにライブラリを記入&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile&lt;/code&gt;とはCarthageのライブラリ管理ファイルです。&lt;br /&gt;
テキストファイルになってて、&lt;br /&gt;
この中にCarthageで管理したいライブラリをまとめます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cartfileファイルの用意&lt;/li&gt;
  &lt;li&gt;Cartfileの編集&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cartfileファイルの用意&quot;&gt;Cartfileファイルの用意&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile&lt;/code&gt;はプロジェクト毎に用意できます。&lt;br /&gt;
対象プロジェクトのディレクトリ上に&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile&lt;/code&gt;を用意します。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~/your/xcode/project/path
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;touch Cartfile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;cartfile編集&quot;&gt;Cartfile編集&lt;/h3&gt;
&lt;p&gt;インストールしたいライブラリを&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile&lt;/code&gt;に記入します。&lt;br /&gt;
例えば&lt;a href=&quot;https://github.com/SwiftyJSON/SwiftyJSON&quot;&gt;SwiftyJSON&lt;/a&gt;であればに次のように記入します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;github &quot;SwiftyJSON/SwiftyJSON&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;バージョン指定をしたい場合は「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage-cartfile-format&quot;&gt;CarthageのCartfileの書き方と個別更新方法&lt;/a&gt;&lt;/span&gt;
」に書き方をまとめてあります。&lt;/p&gt;

&lt;h2 id=&quot;cartfileからframework作成&quot;&gt;Cartfileからframework作成&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile&lt;/code&gt;の準備ができたら&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;コマンドでフレームワークを作成します。&lt;br /&gt;
オプションに&lt;code class=&quot;highlighter-rouge&quot;&gt;--platform&lt;/code&gt;と&lt;code class=&quot;highlighter-rouge&quot;&gt;--no-use-binaries&lt;/code&gt;をつけます。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;オプション&lt;/th&gt;
      &lt;th&gt;説明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;--platform&lt;/td&gt;
      &lt;td&gt;対象プラットフォーム指定。未指定は全環境のフレームワークを作成します&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;--no-use-binaries&lt;/td&gt;
      &lt;td&gt;予めビルドされたバイナリを使わずコードからビルドします&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;コマンドを実行するとframework作成処理が走ります。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;carthage update &lt;span class=&quot;nt&quot;&gt;--platform&lt;/span&gt; iOS &lt;span class=&quot;nt&quot;&gt;--no-use-binaries&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;***&lt;/span&gt; Fetching SwiftyJSON
&lt;span class=&quot;k&quot;&gt;***&lt;/span&gt; Checking out SwiftyJSON at &lt;span class=&quot;s2&quot;&gt;&quot;5.0.0&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;***&lt;/span&gt; xcodebuild output can be found &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; /var/folders/45/7f_wlrcs3xv6rmstcz2l5_000000gn/T/carthage-xcodebuild.IBF3eg.log
&lt;span class=&quot;k&quot;&gt;***&lt;/span&gt; Building scheme &lt;span class=&quot;s2&quot;&gt;&quot;SwiftyJSON iOS&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;SwiftyJSON.xcworkspace
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;成功すると&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage&lt;/code&gt;ディレクトリと&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile.resolved&lt;/code&gt;ファイルが作成されます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cartfile.resolved
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;で最終的な依存ライブラリ情報をまとめたテキストファイル&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Carthage
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;で作成されたライブラリのフレームワークが格納されたディレクトリ&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cartfile.resolvedの詳細については「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage-team-collaboration&quot;&gt;Carthage bootstrapとGit管理をチーム運用観点で整理&lt;/a&gt;&lt;/span&gt;
」でまとめてあります。&lt;/p&gt;

&lt;h2 id=&quot;プロジェクトにframeworkをリンク&quot;&gt;プロジェクトにframeworkをリンク&lt;/h2&gt;
&lt;p&gt;frameworkはプロジェクトにリンクしないと使えません。&lt;br /&gt;
プロジェクトの&lt;code class=&quot;highlighter-rouge&quot;&gt;Target &amp;gt; General &amp;gt; Linked frameworks and Libraries&lt;/code&gt;を ＋ ボタンを押してください。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/1.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/1.png&quot; width=&quot;100%&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;フレームワーク／ライブラリの選択画面が出るので、&lt;code class=&quot;highlighter-rouge&quot;&gt;Add Other...&lt;/code&gt; ボタンを押してください。
&lt;a href=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/2.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/2.png&quot; width=&quot;100%&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ここで先程作成したframeworkを指定します。&lt;br /&gt;
なおフレームワークは、&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage/Build/iOS&lt;/code&gt;ディレクトリの中にあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/3.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/3.png&quot; width=&quot;100%&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;frameworkを選ぶとXcodeプロジェクトに追加されます。&lt;br /&gt;
このとき&lt;strong&gt;Do Not Embed&lt;/strong&gt;になってることを確認してください。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/4.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/4.png&quot; width=&quot;100%&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これでプロジェクトにframeworkがリンクされて、&lt;br /&gt;
コード上のimportで対象frameworkを見つけられるようになります。&lt;/p&gt;

&lt;p&gt;なお、ボタンをポチポチせずにframeworkをドラッグ＆ドロップでも追加できます。&lt;/p&gt;

&lt;h3 id=&quot;注意embed-contentだとビルドエラーになる&quot;&gt;注意：Embed Contentだとビルドエラーになる&lt;/h3&gt;

&lt;p&gt;frameworkのリンク経路は、&lt;code class=&quot;highlighter-rouge&quot;&gt;Target &amp;gt; General&lt;/code&gt;と&lt;code class=&quot;highlighter-rouge&quot;&gt;Target &amp;gt; Build Phases&lt;/code&gt;の2つあり&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;General&lt;/code&gt;からframeworkを追加すると、デフォルトでは&lt;code class=&quot;highlighter-rouge&quot;&gt;Embed &amp;amp; Sign&lt;/code&gt;になります。&lt;br /&gt;
このままビルドすると次のようなビルドエラーが起きます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Multiple commands produce '.../YOUR-APP-NAME.app/Frameworks/&amp;lt;FRAMEWORK NAME&amp;gt;.framework':

1) Target '&amp;lt;YOUR TARGET NAME&amp;gt;' has copy command from
'/your/project/path/Carthage/Build/iOS/&amp;lt;FRAMEWORK NAME&amp;gt;.framework' to '.../YOUR-APP-NAME.app/Frameworks/&amp;lt;FRAMEWORK NAME&amp;gt;.framework'

2) That command depends on command in Target '&amp;lt;YOUR TARGET NAME&amp;gt;': script phase “Run Script”
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Embedded Frameworkではないので、&lt;code class=&quot;highlighter-rouge&quot;&gt;Do Not Embed&lt;/code&gt;に直してください。&lt;/p&gt;

&lt;h2 id=&quot;ビルドフェイズにフレームワークのコピースクリプトを作成&quot;&gt;ビルドフェイズにフレームワークのコピースクリプトを作成&lt;/h2&gt;
&lt;p&gt;リンクでビルドは通りますが、プロダクト内にframeworkが配置されていません。&lt;br /&gt;
&lt;strong&gt;ビルド時にframeworkをコピーするスクリプトを用意します。&lt;/strong&gt;&lt;br /&gt;
コピー処理は&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage copy-frameworks&lt;/code&gt;コマンドを使います。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ビルドフェイズにスクリプトフェイズ追加&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage copy-frameworks&lt;/code&gt;コマンドをセット&lt;/li&gt;
  &lt;li&gt;スクリプトの入力情報をセット&lt;/li&gt;
  &lt;li&gt;スクリプトの出力情報をセット&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1-ビルドフェイズにスクリプトフェイズ追加&quot;&gt;1. ビルドフェイズにスクリプトフェイズ追加&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Build Phases&lt;/code&gt;上の ＋ ボタンを押して&lt;code class=&quot;highlighter-rouge&quot;&gt;New Run Script Phase&lt;/code&gt;を選ぶと&lt;code class=&quot;highlighter-rouge&quot;&gt;Run Script&lt;/code&gt;フェイズが作成されます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/5.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/5.png&quot; width=&quot;100%&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-carthage-copy-frameworksコマンドをセット&quot;&gt;2. &lt;code class=&quot;highlighter-rouge&quot;&gt;carthage copy-frameworks&lt;/code&gt;コマンドをセット&lt;/h3&gt;
&lt;p&gt;Shellはシェルコマンドが呼べればいいので&lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/sh&lt;/code&gt;のままです。&lt;br /&gt;
スクリプト内で&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage copy-frameworks&lt;/code&gt;コマンドを追記します。&lt;br /&gt;
絶対パスでも相対パスでもパスが通っていればどちらでも大丈夫です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/6.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/6.png&quot; width=&quot;100%&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-スクリプトの入力情報をセット&quot;&gt;3. スクリプトの入力情報をセット&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage copy-frameworks&lt;/code&gt;はframeworkのパスを渡すと、ビルド対象プロジェクト内にコピーします。&lt;br /&gt;
厳密には&lt;code class=&quot;highlighter-rouge&quot;&gt;$BUILD_PRODUCTS_DIR/$FRAMEWORKS_FOLDER_PATH&lt;/code&gt;パスにコピーします。&lt;a href=&quot;https://github.com/Carthage/Carthage/blob/f656edfe35651b54eec50d814e79d079f8eea7c4/Source/carthage/CopyFrameworks.swift#L25&quot;&gt;GitHub/Carthage&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/7.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/7.png&quot; width=&quot;100%&quot; alt=&quot;Carthage Xcode Build Phases Run Script Input Files&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-スクリプトの出力情報をセット&quot;&gt;4. スクリプトの出力情報をセット&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Output Files&lt;/code&gt;はコピー先を指定します。&lt;/p&gt;

&lt;p&gt;実は&lt;code class=&quot;highlighter-rouge&quot;&gt;Output Files&lt;/code&gt;は指定せずとも動作に問題はありません。&lt;strong&gt;しかしビルドパフォーマンスに影響します。&lt;/strong&gt;&lt;br /&gt;
詳しくは「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage-measure-copy-speed-with-output-files&quot;&gt;CarthageのビルドフェイズでOutput Files指定による速度調査&lt;/a&gt;&lt;/span&gt;
」に調査結果をまとめてあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/8.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/8.png&quot; width=&quot;100%&quot; alt=&quot;Carthage Xcode Build Phases Run Script Output Files&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;注意-carthage-copy-frameworksを忘れるとランタイムエラー&quot;&gt;注意: carthage copy-frameworksを忘れるとランタイムエラー&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage copy-frameworks&lt;/code&gt;コマンドを実行しなくてもビルドは通ります。&lt;br /&gt;
しかし実行すると次のようなにライブラリのロードエラーが起きます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dyld: Library not loaded: @rpath/SwiftyJSON.framework/SwiftyJSON
  Referenced from: /Users/mothule/Library/Developer/CoreSimulator/Devices/1DB7E7C4-D7CD-44BA-B3F9-F66DC4E5EC51/data/Containers/Bundle/Application/6B0FDFCC-9D12-47D5-9B74-B837BE8FC983/UseCarthage.app/UseCarthage
  Reason: image not found
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;これはプロダクト内にframeworkが配置されてないことで、&lt;br /&gt;
実行環境にプロダクトがインストールされてもframeworkが見つからずdyldがランタイムエラーを起こすためです。&lt;/p&gt;

&lt;h3 id=&quot;注意-input-filesで渡すframeworkのパスを間違えるとビルドエラー&quot;&gt;注意: Input Filesで渡すframeworkのパスを間違えるとビルドエラー&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage copy-frameworks&lt;/code&gt;コマンドに渡すframeworkのパスが間違っているとビルドエラーが発生します。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Input Files&lt;/code&gt;または&lt;code class=&quot;highlighter-rouge&quot;&gt;Input File Lists&lt;/code&gt;で渡してるframeworkのパスが正しいか確認してください。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Could not find framework &quot;&amp;lt;framework name&amp;gt;&quot; at path &amp;lt;wrong framework path&amp;gt;.
Ensure that the given path is appropriately entered and that your &quot;Input Files&quot; and &quot;Input File Lists&quot; have been entered correctly.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;フレームワークのパスはまとめて指定も可能&quot;&gt;フレームワークのパスはまとめて指定も可能&lt;/h3&gt;

&lt;p&gt;Input Filesに各フレームワークのパスをセットしなくても、xcfilelistという拡張子で指定することで一律管理も可能です。
詳細は「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage-use-xcfilelist&quot;&gt;CarthageでInput File Listsにxcfilelistを渡す利点と方法&lt;/a&gt;&lt;/span&gt;
」にまとめてあります。&lt;/p&gt;

&lt;h2 id=&quot;ライブラリを追加する&quot;&gt;ライブラリを追加する&lt;/h2&gt;
&lt;p&gt;新しくframeworkを追加や更新する場合は、&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage copy-frameworks&lt;/code&gt;コマンドの登録以外の作業をやります。&lt;br /&gt;
また&lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt;にオプションが一つ増えます&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Cartfileにライブラリ追加&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;でライブラリ個別更新&lt;/li&gt;
  &lt;li&gt;リンクにframeworkを追加&lt;/li&gt;
  &lt;li&gt;コピースクリプトのInput FilesとOutput Filesに追加&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新しくビルドフェイズにスクリプトを追加はしません。&lt;/p&gt;

&lt;h3 id=&quot;carthage-updateでライブラリ個別更新&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;でライブラリ個別更新&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;とするとCartfileにかかれている全てのライブラリが対象となります。&lt;br /&gt;
他のライブラリのバージョンは更新せず追加したライブラリだけのframework作成をしたい場合は、&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;にライブラリ名を渡します。&lt;/p&gt;

&lt;p&gt;例えば新しく追加したライブラリが&lt;code class=&quot;highlighter-rouge&quot;&gt;SDWebImage&lt;/code&gt;であれば、コマンドラインは次のようになります。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;carthage update &lt;span class=&quot;nt&quot;&gt;--platform&lt;/span&gt; iOS &lt;span class=&quot;nt&quot;&gt;--no-use-binaries&lt;/span&gt; SDWebImage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;これで既存ライブラリは更新されません。&lt;/p&gt;

&lt;h2 id=&quot;もっと体系的に理解する&quot;&gt;もっと体系的に理解する&lt;/h2&gt;

&lt;p&gt;この記事では、記事の読みやすいよう導入に絞ってます。
もしチーム運用、git管理、ライブラリのバージョン運用など使い続けたら必要になる部分は別記事に分けており、&lt;br /&gt;
「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage&quot;&gt;Carthageの使い方を体系的に理解する&lt;/a&gt;&lt;/span&gt;
」からまとめて知ることができます。&lt;/p&gt;</content><author><name></name></author><category term="ios" /><category term="carthage" /><summary type="html">Carthageの導入はちょっとした漏れでエラーにハマります。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-14-ios-carthage-install-guide/eyecatch.png" /></entry><entry><title type="html">CarthageでInput File Listsにxcfilelistを渡す利点と方法</title><link href="https://blog.mothule.com/ios/carthage/ios-carthage-use-xcfilelist" rel="alternate" type="text/html" title="CarthageでInput File Listsにxcfilelistを渡す利点と方法" /><published>2020-05-13T00:00:00+09:00</published><updated>2020-05-13T04:58:36+09:00</updated><id>https://blog.mothule.com/ios/carthage/ios-carthage-use-xcfilelist</id><content type="html" xml:base="https://blog.mothule.com/ios/carthage/ios-carthage-use-xcfilelist">&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xcfilelist&lt;/code&gt;で依存ライブラリを管理すると楽です&lt;/p&gt;

&lt;p&gt;この記事は&lt;code class=&quot;highlighter-rouge&quot;&gt;xcfilelist&lt;/code&gt;を使って&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage&lt;/code&gt;の環境を構築する方法と利点について説明します。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Carghage&lt;/code&gt;の基本や使い方の詳細は「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage&quot;&gt;Carthageの使い方を体系的に理解する&lt;/a&gt;&lt;/span&gt;
」にまとめてあります。&lt;/p&gt;

&lt;h2 id=&quot;carthage公式解説に出てくるxcfilelist&quot;&gt;Carthage公式解説に出てくるxcfilelist&lt;/h2&gt;

&lt;p&gt;Carthageのインストール解説記事には、&lt;code class=&quot;highlighter-rouge&quot;&gt;xcfilelist&lt;/code&gt;を使った解説は見かけません。&lt;br /&gt;
大抵&lt;code class=&quot;highlighter-rouge&quot;&gt;Input Files&lt;/code&gt;に直接パスを指定する記事が多いです。&lt;br /&gt;
しかし、&lt;a href=&quot;https://github.com/Carthage/Carthage&quot;&gt;Carthageの公式&lt;/a&gt;では&lt;code class=&quot;highlighter-rouge&quot;&gt;xcfilelist&lt;/code&gt;を使っており、むしろそっちがメインにも見えます。&lt;/p&gt;

&lt;h3 id=&quot;xcfilelistの正体&quot;&gt;xcfilelistの正体&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xcfilelist&lt;/code&gt;はXcodeのファイル一覧を表すファイル・タイプです。&lt;br /&gt;
といってもただのテキストファイルです。&lt;br /&gt;
テキストエディタでファイルパスを列挙して、ファイル保存時に拡張子を&lt;code class=&quot;highlighter-rouge&quot;&gt;.xcfilelist&lt;/code&gt;とするだけです。&lt;/p&gt;

&lt;h2 id=&quot;xcfilelistを使う場所&quot;&gt;xcfilelistを使う場所&lt;/h2&gt;

&lt;p&gt;公式では英文で&lt;code class=&quot;highlighter-rouge&quot;&gt;xcfilelist&lt;/code&gt;を見かけますが、これを使う場所がパッと見では分かりません。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;xcfilelist&lt;/code&gt;を使う場所は下の画像の&lt;code class=&quot;highlighter-rouge&quot;&gt;Input File Lists&lt;/code&gt;と&lt;code class=&quot;highlighter-rouge&quot;&gt;Output File List&lt;/code&gt;です。&lt;br /&gt;
この中に&lt;code class=&quot;highlighter-rouge&quot;&gt;xcfilelist&lt;/code&gt;のパスを指定します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-13-ios-carthage-use-xcfilelist/1.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-13-ios-carthage-use-xcfilelist/1.png&quot; width=&quot;100%&quot; alt=&quot;XcodeBuildPhaseのCarthage用RunScriptPhase&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;input-file-listsを使う利点&quot;&gt;Input File Listsを使う利点&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Input Files&lt;/code&gt;でframeworkのパスを指定するほうが仕組み理解という点では分かりやすいです。
&lt;code class=&quot;highlighter-rouge&quot;&gt;Input File Lists&lt;/code&gt;を使う利点がないと使う気にならないと思います。&lt;/p&gt;

&lt;p&gt;使う利点は、一度&lt;code class=&quot;highlighter-rouge&quot;&gt;xcfilelist&lt;/code&gt;のパスを指定すれば、&lt;code class=&quot;highlighter-rouge&quot;&gt;Run Script&lt;/code&gt;の使いにくいUIを使わなくて済みます。  &lt;br /&gt;
またフレームワークの追加や削除時に&lt;code class=&quot;highlighter-rouge&quot;&gt;xcodeproj&lt;/code&gt;がフレームワークのリンク設定のみなので衝突時の範囲が狭くなります。&lt;/p&gt;

&lt;h2 id=&quot;xcfilelistを用意する&quot;&gt;xcfilelistを用意する&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xcfilelist&lt;/code&gt;はパスさえ合っていればどこに置いても問題ないですが、&lt;br /&gt;
他環境でも動くようにまずはgit管理下が必須だと思います。&lt;br /&gt;
次に編集しやすさ、環境パスが使える、Xcodeで使うファイルと考えたら&lt;br /&gt;
&lt;strong&gt;プロジェクトディレクトリ配下に置くことが最適です。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-13-ios-carthage-use-xcfilelist/2.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-13-ios-carthage-use-xcfilelist/2.png&quot; width=&quot;50%&quot; alt=&quot;Xcode-Project-Navigator&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;中身は次のように&lt;code class=&quot;highlighter-rouge&quot;&gt;Input Files&lt;/code&gt;で指定するパスを並べるだけです。
これを&lt;code class=&quot;highlighter-rouge&quot;&gt;.xcfilelist&lt;/code&gt;として保存すれば準備は整います。
ファイル名は何でもいいです。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(SRCROOT)/Carthage/Build/iOS/AdjustSdk.framework
$(SRCROOT)/Carthage/Build/iOS/SKPhotoBrowser.framework
$(SRCROOT)/Carthage/Build/iOS/SDWebImage.framework
$(SRCROOT)/Carthage/Build/iOS/AFNetworking.framework
$(SRCROOT)/Carthage/Build/iOS/AdjustSdkWebBridge.framework
$(SRCROOT)/Carthage/Build/iOS/PAYJP.framework
$(SRCROOT)/Carthage/Build/iOS/AdjustSdkIm.framework
$(SRCROOT)/Carthage/Build/iOS/SVProgressHUD.framework
$(SRCROOT)/Carthage/Build/iOS/SwiftyJSON.framework
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;xcfilelistをinput-file-listsに渡す&quot;&gt;xcfilelistをInput File Listsに渡す&lt;/h2&gt;

&lt;p&gt;Xcodeの&lt;code class=&quot;highlighter-rouge&quot;&gt;Build Phases&lt;/code&gt;の&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage&lt;/code&gt;用スクリプトフェイズの&lt;code class=&quot;highlighter-rouge&quot;&gt;Input File Lists&lt;/code&gt;に先程用意した&lt;code class=&quot;highlighter-rouge&quot;&gt;.xcfilelist&lt;/code&gt;のパスを指定します。&lt;/p&gt;

&lt;p&gt;先程の用意した場所であれば、&lt;code class=&quot;highlighter-rouge&quot;&gt;$(SRCROOT)/$(PROJECT_NAME)/carthage-input-file-list.xcfilelist&lt;/code&gt;になります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-13-ios-carthage-use-xcfilelist/3.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-13-ios-carthage-use-xcfilelist/3.png&quot; width=&quot;100%&quot; alt=&quot;XcodeのInputFileLists&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;output-file-listsもxcfilelistを使う&quot;&gt;Output File Listsもxcfilelistを使う&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Output File Lists&lt;/code&gt;も同様に&lt;code class=&quot;highlighter-rouge&quot;&gt;xcfilelist&lt;/code&gt;として出力パスを列挙しておけば&lt;code class=&quot;highlighter-rouge&quot;&gt;xcfilelist&lt;/code&gt;のパスを指定するだけです。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/AdjustSdk.framework
$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/SKPhotoBrowser.framework
$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/SDWebImage.framework
$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/AFNetworking.framework
$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/AdjustSdkWebBridge.framework
$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/PAYJP.framework
$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/AdjustSdkIm.framework
$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/SVProgressHUD.framework
$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/SwiftyJSON.framework
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;こちらも&lt;code class=&quot;highlighter-rouge&quot;&gt;Input File Lists&lt;/code&gt;と同じ場所場所であれば&lt;code class=&quot;highlighter-rouge&quot;&gt;Output File Lists&lt;/code&gt;で指定するパスは、&lt;code class=&quot;highlighter-rouge&quot;&gt;$(SRCROOT)/$(PROJECT_NAME)/carthage-output-file-list.xcfilelist&lt;/code&gt;になります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-13-ios-carthage-use-xcfilelist/4.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-13-ios-carthage-use-xcfilelist/4.png&quot; width=&quot;50%&quot; alt=&quot;XcodeのOutputFileLists&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;output-file-listsを指定する理由&quot;&gt;Output File Listsを指定する理由&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Output Files&lt;/code&gt;や&lt;code class=&quot;highlighter-rouge&quot;&gt;Output File Lists&lt;/code&gt;でコピー先のパスを指定しますが、実は指定しなくてもコピー処理は成功し、動作も問題ありません。&lt;br /&gt;
なぜ指定するのかは「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage-measure-copy-speed-with-output-files&quot;&gt;CarthageのビルドフェイズでOutput Files指定による速度調査&lt;/a&gt;&lt;/span&gt;
」に詳細をまとめてます。&lt;/p&gt;

&lt;h2 id=&quot;後からでも対応できる&quot;&gt;後からでも対応できる&lt;/h2&gt;
&lt;p&gt;この対応は、プロジェクトが初期段階でも後からでも対応できます。&lt;br /&gt;
ライブラリが多くても手間はそこまで変わりません。&lt;/p&gt;</content><author><name></name></author><category term="ios" /><category term="carthage" /><summary type="html">xcfilelistで依存ライブラリを管理すると楽です</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-13-ios-carthage-use-xcfilelist/eyecatch.png" /></entry><entry><title type="html">CarthageのビルドフェイズでOutput Files指定による速度調査</title><link href="https://blog.mothule.com/ios/carthage/ios-carthage-measure-copy-speed-with-output-files" rel="alternate" type="text/html" title="CarthageのビルドフェイズでOutput Files指定による速度調査" /><published>2020-05-13T00:00:00+09:00</published><updated>2020-05-13T03:06:05+09:00</updated><id>https://blog.mothule.com/ios/carthage/ios-carthage-measure-copy-speed-with-output-files</id><content type="html" xml:base="https://blog.mothule.com/ios/carthage/ios-carthage-measure-copy-speed-with-output-files">&lt;p&gt;この記事はXcodeのビルドフェイズ時にCarthageのフレームワークコピー用スクリプトのOutput Filesの有無によるビルドパフォーマンスについて調査した記事です。&lt;/p&gt;

&lt;p&gt;なおCarthageのインストールや基礎など詳細は「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage&quot;&gt;Carthageの使い方を体系的に理解する&lt;/a&gt;&lt;/span&gt;
」にまとめてあります。&lt;/p&gt;

&lt;h2 id=&quot;調査のきっかけ&quot;&gt;調査のきっかけ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Carthage/Carthage#quick-start&quot;&gt;Carthage Quick Start&lt;/a&gt;や&lt;a href=&quot;https://github.com/Carthage/Carthage#adding-frameworks-to-an-application&quot;&gt;Carghage Adding frameworks to an application&lt;/a&gt;には、&lt;code class=&quot;highlighter-rouge&quot;&gt;Output Files&lt;/code&gt;や&lt;code class=&quot;highlighter-rouge&quot;&gt;Output File Lists&lt;/code&gt;を設定しろと書かれています。&lt;/p&gt;

&lt;p&gt;しかし、&lt;a href=&quot;https://github.com/Carthage/Carthage/blob/master/Source/carthage/CopyFrameworks.swift&quot;&gt;carthage copy-frameworksのコード&lt;/a&gt;では使われていません。&lt;/p&gt;

&lt;p&gt;最初はただの更新漏れかと思ったが、調べたら&lt;a href=&quot;https://github.com/Carthage/Carthage/pull/2025&quot;&gt;Pull Request&lt;/a&gt;を見つけました。&lt;/p&gt;

&lt;p&gt;どうやらWWDCの発表によると、&lt;code class=&quot;highlighter-rouge&quot;&gt;Output Files&lt;/code&gt;が設定されていると、&lt;code class=&quot;highlighter-rouge&quot;&gt;Input Files&lt;/code&gt;の変更がなければスクリプトの実行をスキップするらしいです。&lt;/p&gt;

&lt;p&gt;つまり&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Output Files&lt;/code&gt;は未設定でも動作上問題はないですが、設定はすることでビルド時間の短縮に繋がる&lt;/strong&gt;ようです。&lt;/p&gt;

&lt;p&gt;では「どれぐらい違うのか？」を調べようと思いました。&lt;/p&gt;

&lt;p&gt;小さな差分でも、開発では何十回もビルドを走らせます。&lt;br /&gt;
トータルタイムでいくと効果は侮れません。&lt;/p&gt;

&lt;h2 id=&quot;調査方法&quot;&gt;調査方法&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;プロジェクトは新規プロジェクトの初期状態＋Carthage&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Output Files&lt;/code&gt;の「あり」「なし」それぞれのビルド時間を10回ずつ測定&lt;/li&gt;
  &lt;li&gt;ビルドを走らせる前に適当なソースファイルを1つ弄ってから実行する&lt;/li&gt;
  &lt;li&gt;ビルド時間はXcodeのPreferences(ShowBuildOperationDuration)を使う&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;フレームワークのコピー処理の有無ということで、&lt;em&gt;Cartfile&lt;/em&gt; はそれっぽい数7個用意。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;github &quot;AFNetworking/AFNetworking&quot;
github &quot;suzuki-0000/SKPhotoBrowser&quot;
github &quot;SVProgressHUD/SVProgressHUD&quot;
github &quot;SwiftyJSON/SwiftyJSON&quot;
github &quot;SDWebImage/SDWebImage&quot;
github &quot;payjp/payjp-ios&quot;
github &quot;adjust/ios_sdk&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;測定結果&quot;&gt;測定結果&lt;/h2&gt;

&lt;p&gt;次の表は調査方法に基づいた調査結果です。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;#&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Output Files&lt;/code&gt;なし&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Output Files&lt;/code&gt;あり&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2.300&lt;/td&gt;
      &lt;td&gt;1.569&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2.521&lt;/td&gt;
      &lt;td&gt;1.427&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;2.229&lt;/td&gt;
      &lt;td&gt;1.455&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;1.867&lt;/td&gt;
      &lt;td&gt;1.493&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;2.516&lt;/td&gt;
      &lt;td&gt;1.343&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;2.364&lt;/td&gt;
      &lt;td&gt;1.710&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;2.158&lt;/td&gt;
      &lt;td&gt;1.568&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;2.360&lt;/td&gt;
      &lt;td&gt;1.467&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;2.123&lt;/td&gt;
      &lt;td&gt;1.575&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;2.243&lt;/td&gt;
      &lt;td&gt;1.479&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Avg&lt;/td&gt;
      &lt;td&gt;2.2681&lt;/td&gt;
      &lt;td&gt;1.5086&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;平均値の差分は0.7595秒つまり34%短縮しました。&lt;/p&gt;

&lt;h2 id=&quot;感想&quot;&gt;感想&lt;/h2&gt;

&lt;p&gt;想定以上の効果がありました。&lt;br /&gt;
調査中も違いを体感で分かるほどです。&lt;br /&gt;
ワンテンポ違いました。&lt;/p&gt;

&lt;p&gt;しかし、仮に仕事で15分おきに1回ビルドを走らせてるとした場合、&lt;br /&gt;
9時間 x 4回 * 0.7595秒 = 27.342秒の違いが出ます。&lt;br /&gt;
大したことないですね…&lt;br /&gt;
でも短時間に何度もビルドを走らせる状況ではチリツモ効果は出てると予想します。&lt;/p&gt;

&lt;p&gt;なお、このパフォーマンスは、Cartfile管理下のライブラリ数とライブラリ規模に依存します。&lt;/p&gt;

&lt;h2 id=&quot;結論&quot;&gt;結論&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;一定のパフォーマンス効果はある&lt;/li&gt;
  &lt;li&gt;おとなしく設定したほうがいい&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="ios" /><category term="carthage" /><summary type="html">この記事はXcodeのビルドフェイズ時にCarthageのフレームワークコピー用スクリプトのOutput Filesの有無によるビルドパフォーマンスについて調査した記事です。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-13-ios-carthage-measure-copy-speed-with-output-files/eyecatch.png" /></entry><entry><title type="html">MacのGoogle日本語入力で変換候補ポップアップが左下とか左上など隅っこに表示される</title><link href="https://blog.mothule.com/mac/google-japanese-input/mac-goolge-japanese-input-bug-fix" rel="alternate" type="text/html" title="MacのGoogle日本語入力で変換候補ポップアップが左下とか左上など隅っこに表示される" /><published>2020-05-13T00:00:00+09:00</published><updated>2020-05-13T16:47:54+09:00</updated><id>https://blog.mothule.com/mac/google-japanese-input/mac-goolge-japanese-input-bug-fix</id><content type="html" xml:base="https://blog.mothule.com/mac/google-japanese-input/mac-goolge-japanese-input-bug-fix">&lt;p&gt;プロセスを再起動すれば直る。&lt;/p&gt;

&lt;p&gt;この記事ではMacのGoogle日本語入力で変換候補ポップアップがおかしくなったので調査して解決方法をまとめたものです。&lt;br /&gt;
なお解決にはシェルコマンドをいくつか叩くのでターミナル.appなどターミナルアプリが必要です。&lt;/p&gt;

&lt;h2 id=&quot;macでgoogle日本語入力がおかしくなる&quot;&gt;MacでGoogle日本語入力がおかしくなる&lt;/h2&gt;

&lt;p&gt;正常稼働してるGoogle日本語入力は、次の画像のようにタイプしてる文字の近くに変換候補が並んだポップアップが表示される。
これがおかしくなると、ポップアップの位置が画面の四隅に固定されてしまう現象が発生する。&lt;/p&gt;

&lt;h3 id=&quot;正常時&quot;&gt;正常時&lt;/h3&gt;

&lt;p&gt;正常時は、タイプしてる文字の近くに表示される。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-13-mac-goolge-japanese-input-bug-fix/1.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-13-mac-goolge-japanese-input-bug-fix/1.png&quot; width=&quot;50%&quot; alt=&quot;GoogleJapaneseInput&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;異常時&quot;&gt;異常時&lt;/h3&gt;

&lt;p&gt;問題がおきると、これが隅っこで表示される。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-13-mac-goolge-japanese-input-bug-fix/2.gif&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-13-mac-goolge-japanese-input-bug-fix/2.gif&quot; width=&quot;50%&quot; alt=&quot;GoogleJapaneseInputWithBug&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;分かってること&quot;&gt;分かってること&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;自分が立ち上げているアプリケーションを全て終了しても解決しない&lt;/li&gt;
  &lt;li&gt;再起動すると解決する&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;仮説&quot;&gt;仮説&lt;/h3&gt;
&lt;p&gt;プロセス再起動で解決するのでは？&lt;/p&gt;

&lt;h2 id=&quot;macのプロセス一覧でgoogle日本語入力を探す&quot;&gt;Macのプロセス一覧でGoogle日本語入力を探す&lt;/h2&gt;

&lt;p&gt;Macでプロセス一覧を見るには&lt;code class=&quot;highlighter-rouge&quot;&gt;ps&lt;/code&gt;コマンドを使う。&lt;/p&gt;

&lt;p&gt;ターミナルで&lt;code class=&quot;highlighter-rouge&quot;&gt;ps aux | grep GoogleJapaneseInput&lt;/code&gt;を実行
このときGoogle Chromeは閉じておく&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ps x | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;GoogleJapaneseInput
  879   ??  S      1:23.75 /Library/Input Methods/GoogleJapaneseInput.app/Contents/MacOS/GoogleJapaneseInput
 1213   ??  S      1:40.55 /Library/Input Methods/GoogleJapaneseInput.app/Contents/Resources/GoogleJapaneseInputRenderer.app/Contents/MacOS/GoogleJapaneseInputRenderer
 2059   ??  S      1:15.08 /Library/Input Methods/GoogleJapaneseInput.app/Contents/Resources/GoogleJapaneseInputConverter.app/Contents/MacOS/GoogleJapaneseInputConverter
99614 s001  S+     0:00.00 &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;GoogleJapaneseInput
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GoogleJapaneseInput&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;GoogleJapaneseInputRenderer&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;GoogleJapaneseInputConverter&lt;/code&gt;のプロセスがヒットする。&lt;br /&gt;
(最後のプロセスはgrepプロセスなので無関係)&lt;/p&gt;

&lt;p&gt;おそらく名前からしてこうだろう。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GoogleJapaneseInput&lt;/code&gt; : 設定全般 or 統括&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GoogleJapaneseInputRenderer&lt;/code&gt; : 描画関係&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GoogleJapaneseInputConverter&lt;/code&gt; : 変換関係&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;変換自体はうまく動いているので、おかしいのは変換以外の2つだと思われる。
もっとも怪しいのは描画を司っているであろう&lt;code class=&quot;highlighter-rouge&quot;&gt;GoogleJapaneseInputRenderer&lt;/code&gt;だと予想。&lt;/p&gt;

&lt;h2 id=&quot;macのプロセスをkillコマンドで終了させる&quot;&gt;Macのプロセスをkillコマンドで終了させる&lt;/h2&gt;

&lt;p&gt;Macでプロセスを終了させるには&lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt;コマンドを使う。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt;コマンドにプロセスIDを渡すとIDに紐づくプロセスにシグナルが送信され終了する。&lt;/p&gt;

&lt;h3 id=&quot;googlejapaneseinputrendererプロセスのプロセスidを探す&quot;&gt;GoogleJapaneseInputRendererプロセスのプロセスIDを探す&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ps&lt;/code&gt;コマンドの結果は表形式でプロセスが並ぶ。
１つ目のカラムはプロセスIDを表す。&lt;/p&gt;

&lt;p&gt;先程の表で&lt;code class=&quot;highlighter-rouge&quot;&gt;GoogleJapaneseInputRenderer&lt;/code&gt;のプロセスIDは&lt;code class=&quot;highlighter-rouge&quot;&gt;1213&lt;/code&gt;になる。&lt;br /&gt;
なおこのプロセスIDはいつもこの値ではないので注意。&lt;/p&gt;

&lt;h3 id=&quot;killコマンドでgooglejapaneseinputrendererを終了させる&quot;&gt;killコマンドでGoogleJapaneseInputRendererを終了させる&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GoogleJapaneseInputRenderer&lt;/code&gt;のプロセスIDが分かったので最終的には、&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;$ kill 1213&lt;/code&gt;をターミナル上で実行すれば&lt;code class=&quot;highlighter-rouge&quot;&gt;GoogleJapaneseInputRenderer&lt;/code&gt;が終了する。&lt;/p&gt;

&lt;h2 id=&quot;macのgoogle日本語入力が直った&quot;&gt;MacのGoogle日本語入力が直った&lt;/h2&gt;
&lt;p&gt;仮説と予想は的中し、&lt;code class=&quot;highlighter-rouge&quot;&gt;GoogleJapaneseInputRenderer&lt;/code&gt;プロセスを終了し、再度テキストエディで文字入力したら&lt;code class=&quot;highlighter-rouge&quot;&gt;GoogleJapaneseInputRenderer&lt;/code&gt;が立ち上がり変換候補ポップアップが文字の近くに戻ってきた。&lt;/p&gt;</content><author><name></name></author><category term="mac" /><category term="google-japanese-input" /><summary type="html">プロセスを再起動すれば直る。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-13-mac-goolge-japanese-input-bug-fix/eyecatch.png" /></entry><entry><title type="html">setNeedsLayoutやlayoutSubviewsなどの役割を整理する</title><link href="https://blog.mothule.com/ios/ios-ui-constraint-layout-update" rel="alternate" type="text/html" title="setNeedsLayoutやlayoutSubviewsなどの役割を整理する" /><published>2020-05-12T00:00:00+09:00</published><updated>2020-05-12T05:47:47+09:00</updated><id>https://blog.mothule.com/ios/ios-ui-constraint-layout-update</id><content type="html" xml:base="https://blog.mothule.com/ios/ios-ui-constraint-layout-update">&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layoutIfNeeded&lt;/code&gt;はビュー位置すぐ分かって便利。&lt;code class=&quot;highlighter-rouge&quot;&gt;layoutSubviews&lt;/code&gt;は呼んだらいけない。&lt;code class=&quot;highlighter-rouge&quot;&gt;setNeedsLayout&lt;/code&gt;はパフォーマンス良し。&lt;/p&gt;

&lt;p&gt;ビュー周りをコーディング中にUIが反映されない不具合に遭遇したら、&lt;br /&gt;
「ビューが反映されていない。とりあえず可能性を潰すために&lt;code class=&quot;highlighter-rouge&quot;&gt;Constraint&lt;/code&gt;や&lt;code class=&quot;highlighter-rouge&quot;&gt;Layout&lt;/code&gt;を更新」&lt;br /&gt;
って思って、Xcode上で&lt;code class=&quot;highlighter-rouge&quot;&gt;constraint&lt;/code&gt;とか&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;って打ったら候補に上がるたくさんのメソッド。
「とりあえずそれぞれ何個か呼べば反映処理は走るだろう・・・」&lt;br /&gt;
なんてことないですか？&lt;/p&gt;

&lt;p&gt;この記事では、&lt;code class=&quot;highlighter-rouge&quot;&gt;setNeedsLayout&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;layoutIfNeeded&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;layoutSubviews&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;updateConstraints&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;setNeedsUpdateConstraints&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;updateConstraintsIfNeeded&lt;/code&gt;について調べて、詳細は省いて噛み砕いて説明します。&lt;/p&gt;

&lt;h2 id=&quot;iosのレイアウト更新をメソッド整理する&quot;&gt;iOSのレイアウト更新をメソッド整理する&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;制約系
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;updateConstraints&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setNeedsUpdateConstraints&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;updateConstraintsIfNeeded&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;レイアウト系
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layoutSubviews&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setNeedsLayout&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layoutIfNeeded&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;updateconstraints&quot;&gt;updateConstraints&lt;/h3&gt;
&lt;p&gt;システムが制約更新に呼ぶ
自分らが直接呼ばない。&lt;/p&gt;

&lt;p&gt;使う用途は、オーバーライドして制約更新の最適化。
そもそも、これをオーバーライドしてまでパフォーマンスを求められる複雑な画面はつくらないほうがいい。&lt;/p&gt;

&lt;h3 id=&quot;setneedsupdateconstraints&quot;&gt;setNeedsUpdateConstraints&lt;/h3&gt;
&lt;p&gt;事前に更新予約することで複数ビュー更新時の無駄な再計算の抑制。
フラグセット処理なので処理は軽い。その場で処理はされない。&lt;/p&gt;

&lt;h3 id=&quot;updateconstraintsifneeded&quot;&gt;updateConstraintsIfNeeded&lt;/h3&gt;
&lt;p&gt;システムがレイアウト更新時に呼ぶ。最新の制約を得たい場合は手動で呼ぶことも可能。
&lt;code class=&quot;highlighter-rouge&quot;&gt;setNeedsUpdateConstraints&lt;/code&gt;の後にこれを呼ぶと制約更新が走る。&lt;/p&gt;

&lt;h3 id=&quot;layoutsubviews&quot;&gt;layoutSubviews&lt;/h3&gt;
&lt;p&gt;制約を使いサブビューのサイズと位置を決定する。&lt;br /&gt;
このメソッドは直接呼んではならない、代わりに&lt;code class=&quot;highlighter-rouge&quot;&gt;setNeedsLayout&lt;/code&gt;使うこと。&lt;br /&gt;
もし、ビューのレイアウトをすぐ欲しい場合は、&lt;code class=&quot;highlighter-rouge&quot;&gt;layoutIfNeeded&lt;/code&gt;を呼ぶこと。&lt;/p&gt;

&lt;h3 id=&quot;setneedslayout&quot;&gt;setNeedsLayout&lt;/h3&gt;
&lt;p&gt;サブビューのレイアウトを無効化する＝次回レイアウト更新時に更新を必須とする。&lt;br /&gt;
全てのレイアウト更新を1回の更新サイクルで済ませられるのでパフォーマンス良い。&lt;/p&gt;

&lt;h3 id=&quot;layoutifneeded&quot;&gt;layoutIfNeeded&lt;/h3&gt;
&lt;p&gt;サブビューが保留中ならすぐさま更新する。更新不要なら何もしない。&lt;br /&gt;
呼んだビューをルートとして、サブビューのレイアウト更新する。&lt;br /&gt;
内部では制約の変更も更新する。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;setNeedsLayout&lt;/code&gt;を呼んだビューで呼ぶとその場でレイアウト更新処理が走る。&lt;/p&gt;

&lt;h2 id=&quot;制約変更してすぐにレイアウトが欲しい場合&quot;&gt;制約変更してすぐにレイアウトが欲しい場合&lt;/h2&gt;
&lt;p&gt;制約を変更した直後に、影響を受けた後のビュー状態が欲しい場合は、&lt;br /&gt;
影響を受けるビューの親ビューの&lt;code class=&quot;highlighter-rouge&quot;&gt;layoutIfNeeded&lt;/code&gt;を呼ぶ。&lt;br /&gt;
これにより無効化されたビューのレイアウト更新が実行されます。&lt;br /&gt;
レイアウト更新は内部で&lt;code class=&quot;highlighter-rouge&quot;&gt;updateConstraints&lt;/code&gt;が呼ばれてから、&lt;code class=&quot;highlighter-rouge&quot;&gt;layoutSubviews&lt;/code&gt;が呼ばれてます。&lt;/p&gt;

&lt;h3 id=&quot;コードで表す&quot;&gt;コードで表す&lt;/h3&gt;

&lt;p&gt;あるUIViewControllerにUILabelが配置されてるとする。&lt;br /&gt;
UILabelは左右と上にsuperviewとConstraintを引いている。&lt;br /&gt;
左右のConstraintsはそれぞれ&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;になっている。&lt;/p&gt;

&lt;p&gt;左右のConstraints(&lt;code class=&quot;highlighter-rouge&quot;&gt;labelRightConstraint&lt;/code&gt;と&lt;code class=&quot;highlighter-rouge&quot;&gt;labelLeftConstraint&lt;/code&gt;)の値を変更。&lt;br /&gt;
ラベルの中身も変更する。&lt;/p&gt;

&lt;p&gt;この状態で制約変更後のラベルの座標が欲しい場合は、&lt;code class=&quot;highlighter-rouge&quot;&gt;layoutIfNeeded&lt;/code&gt;を呼ぶ。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;setNeedsLayout&lt;/code&gt;は呼ばなくてもラベルの変更によりレイアウトが無効化（更新必須化）されている。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;labelRightConstraint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constant&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;30.0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;labelLeftConstraint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constant&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;40.0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;asdfasdfasdfasdf&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;layoutIfNeeded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ラベルX:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;origin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;コンソール&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ラベルX: 40.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;親ビューを更新しないといけない&quot;&gt;親ビューを更新しないといけない&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layoutIfNeeded&lt;/code&gt;をラベルの親ビューではなく、ラベル自身で呼んでも変更されない。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;labelRightConstraint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constant&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;30.0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;labelLeftConstraint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constant&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;40.0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;asdfasdfasdfasdf&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;layoutIfNeeded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ラベルX:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;origin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;コンソール&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ラベルX: 16.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;setneedslayoutは無効化するだけ&quot;&gt;setNeedsLayoutは無効化するだけ&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setNeedsLayout&lt;/code&gt;を呼ぶと次回更新時に更新されるが、その場で更新はされない。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;labelRightConstraint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constant&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;30.0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;labelLeftConstraint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constant&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;40.0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;asdfasdfasdfasdf&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;setNeedsLayout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ラベルX:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;origin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;コンソール&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ラベルX: 16.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;constraint更新してもフレーム位置は変わらない&quot;&gt;Constraint更新してもフレーム位置は変わらない&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setNeedsUpdateConstraints&lt;/code&gt;と&lt;code class=&quot;highlighter-rouge&quot;&gt;updateConstraintsIfNeeded&lt;/code&gt;で制約更新しても&lt;br /&gt;
レイアウト更新はされないので、ラベルの位置は更新されない。&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;labelRightConstraint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constant&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;30.0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;labelLeftConstraint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constant&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;40.0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;asdfasdfasdfasdf&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;setNeedsUpdateConstraints&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;updateConstraintsIfNeeded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ラベルX:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;origin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;コンソール&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ラベルX: 16.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;あまり使うケース少ない&quot;&gt;あまり使うケース少ない&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setNeedsLayout&lt;/code&gt;と&lt;code class=&quot;highlighter-rouge&quot;&gt;setNeedsUpdateConstraints&lt;/code&gt;はパフォーマンス良いと説明されている。&lt;br /&gt;
だけど呼ばなくても最近のiPhoneでは動く。&lt;br /&gt;
そしてUIベースのアプリは、これが必要なほど凝ったUIは作るべきではないと私は思う。&lt;/p&gt;

&lt;p&gt;かろうじて使うのは&lt;code class=&quot;highlighter-rouge&quot;&gt;layoutIfNeeded&lt;/code&gt;だろうか。&lt;/p&gt;</content><author><name></name></author><category term="ios" /><summary type="html">layoutIfNeededはビュー位置すぐ分かって便利。layoutSubviewsは呼んだらいけない。setNeedsLayoutはパフォーマンス良し。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-12-ios-ui-constraint-layout-update/0.png" /></entry></feed>