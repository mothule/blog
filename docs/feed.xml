<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ja-JP"><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://blog.mothule.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.mothule.com/" rel="alternate" type="text/html" hreflang="ja-JP" /><updated>2020-06-12T18:18:13+09:00</updated><id>https://blog.mothule.com/feed.xml</id><title type="html">もちゅろぐ</title><subtitle>iOSやSwift,RubyやRailsなどiPhoneアプリ開発とサーバーサイド開発を中心に綴っている技術ブログ</subtitle><entry><title type="html">お前らはPO業務を舐めすぎている</title><link href="https://blog.mothule.com/notebook/service-design/notebook-service-design-wrong-po-works" rel="alternate" type="text/html" title="お前らはPO業務を舐めすぎている" /><published>2020-06-02T00:00:00+09:00</published><updated>2020-06-02T12:54:06+09:00</updated><id>https://blog.mothule.com/notebook/service-design/notebook-service-design-wrong-po-works</id><content type="html" xml:base="https://blog.mothule.com/notebook/service-design/notebook-service-design-wrong-po-works">&lt;p&gt;PO(Product Owner)はアジャイルのスクラムで定義された用語です。&lt;br /&gt;
チーム内では、施策や機能の策定、取捨選択によるプロダクト成長に責任を持ちます。&lt;br /&gt;
もしPOがいなくなったら、市場におけるライバルとの差別化や対象ユーザーの理解、利用者の体験最大化が全部停滞します。&lt;/p&gt;

&lt;h2 id=&quot;poをチームマネージャー勘違いするな&quot;&gt;POをチームマネージャー勘違いするな&lt;/h2&gt;
&lt;p&gt;POをチームメンバーの管理をする業務とか、企画の裁量権持った人だと盛大な勘違いする人がいます。&lt;br /&gt;
ましてやPOを掛け持ちさせる上長がいたりします。&lt;br /&gt;
そんな適当な考えでプロダクトが成長するなら誰も苦労しないです。&lt;br /&gt;
もう少しPOという役割の重要性を理解し、健全なスクラムチームが増えることを願います。&lt;/p&gt;

&lt;h2 id=&quot;poの本業はプロダクト成長&quot;&gt;POの本業はプロダクト成長&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;担当サービスおいて誰よりも詳しい&lt;/li&gt;
  &lt;li&gt;指標をいつもに見てる(売上だけでなくUXやCXの指標定義や分析を行う)&lt;/li&gt;
  &lt;li&gt;その上で次の施策について導き出す&lt;/li&gt;
  &lt;li&gt;施策の優先度を↑の観点から決めれる&lt;/li&gt;
  &lt;li&gt;プロモ／協力会社／会社戦略などの要望とユーザー目線のすり合わせができる&lt;/li&gt;
  &lt;li&gt;slackの担当領域chに食いついており、担当領域の議論や疑問が発生したら即解決して他メンバーに無駄な時間を費やせない&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;こんなpoはpoではない&quot;&gt;こんなPOはPOではない&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;問題が起きてから動く&lt;/li&gt;
  &lt;li&gt;聞かれた優先順位を並べるだけ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;それだとユーザー目線は育たないし、UX向上しないし、成長速度は鈍牛、プロダクトは偏って成長する。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;↑これはもうただのメンテナンス。調整屋。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;これでユーザーファーストとか言ってたらアイス両手に持ったデブが「私ダイエットする！」って言ってるのと同義です。&lt;/p&gt;

&lt;h2 id=&quot;エンジニアが技術でux提供するとしたらpoは&quot;&gt;エンジニアが技術でUX提供するとしたらPOは&lt;/h2&gt;
&lt;p&gt;POはプロダクトを通してUXを提供することが責務です。&lt;br /&gt;
規模によってはCX観点です。&lt;/p&gt;

&lt;p&gt;CXを簡単に言うなら「ユーザーがニーズを感じたその日からプロダクトを通して実際にニーズを達成して人生に良い体験をするまで」のプロダクトだけでなくそれを取り巻く環境も巻き込んだ視野の広い観点です。&lt;/p&gt;

&lt;p&gt;話を戻します。&lt;br /&gt;
POにとってプロダクト成長、つまり「プロダクトを開発する」とは、&lt;br /&gt;
人と多数の機能をつなぎ合わせること、いわばプログラミングです。&lt;/p&gt;

&lt;p&gt;置かれた状況下(時間、予算、市場)でツールやプラクティスを駆使して情報を獲得し&lt;br /&gt;
それらをプロダクトのミッション達成するにはどう繋げて実現するかに全力を注ぐことです。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;iOSエンジニアはiOSアプリ開発に責任を持つ人&lt;/li&gt;
  &lt;li&gt;AndroidエンジニアはAndroidアプリ開発に責任を持つ人&lt;/li&gt;
  &lt;li&gt;WebエンジニアはWebアプリ開発に責任を持つ人&lt;/li&gt;
  &lt;li&gt;BackendエンジニアはBackend開発に責任を持つ人&lt;/li&gt;
  &lt;li&gt;POはプロダクト開発に責任を持つ人&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;poとはプロダクト開発に必要不可欠な戦力&quot;&gt;POとはプロダクト開発に必要不可欠な戦力&lt;/h2&gt;

&lt;p&gt;立たされた市場(ユーザー特性やライバル)を把握し&lt;br /&gt;
プロダクト全体つまりCX目線で強み弱み、不足を把握して&lt;br /&gt;
プロダクトの分析や成長をメインとするポジションです。&lt;/p&gt;

&lt;h3 id=&quot;例えばpoがいないと&quot;&gt;例えばPOがいないと&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;上層部より出された方針／戦略においてプロダクトの弱みや不足に気づく人がいない。&lt;/li&gt;
  &lt;li&gt;方針／戦略からプロダクトの施策で何をやるべきか話を進められる人がいない&lt;/li&gt;
  &lt;li&gt;プロダクト成長におけるKPIツリーを作れる人がいない&lt;/li&gt;
  &lt;li&gt;プロダクトの体調管理をできてる人がいない
    &lt;ul&gt;
      &lt;li&gt;調子が悪いとき、どこが問題か分析する人がいない&lt;/li&gt;
      &lt;li&gt;業界トレンドやライバル、プロダクトの市場、プロダクトが提供するサービスの知識から有効な解決策を出せる人がいない&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;慢性なユーザー理解してる人がいない&lt;/li&gt;
  &lt;li&gt;↑上記を仕方なく他メンバーが片手間でやっている&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;新人にpoをやらせるな&quot;&gt;新人にPOをやらせるな&lt;/h2&gt;

&lt;p&gt;上記で説明したPOが持つ責任を新人など経験浅い人材がこなせるわけないです。&lt;/p&gt;</content><author><name></name></author><category term="notebook" /><category term="service-design" /><summary type="html">PO(Product Owner)はアジャイルのスクラムで定義された用語です。 チーム内では、施策や機能の策定、取捨選択によるプロダクト成長に責任を持ちます。 もしPOがいなくなったら、市場におけるライバルとの差別化や対象ユーザーの理解、利用者の体験最大化が全部停滞します。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-06-02-notebook-service-design-wrong-po-works/eyecatch.png" /></entry><entry><title type="html">iOSアプリのバリデーションについて考えてみた</title><link href="https://blog.mothule.com/ios/swift/ios-swift-validation" rel="alternate" type="text/html" title="iOSアプリのバリデーションについて考えてみた" /><published>2020-05-27T00:00:00+09:00</published><updated>2020-05-27T01:24:28+09:00</updated><id>https://blog.mothule.com/ios/swift/ios-swift-validation</id><content type="html" xml:base="https://blog.mothule.com/ios/swift/ios-swift-validation">&lt;p&gt;アプリの入力フォームで無効なデータを登録しないようバリデーションを挟むことがあります。
大抵はAPI側で検証して問題があればバリデーションエラーとしてレスポンスを返し、
受け取ったクライアント側は結果をユーザーに伝えます。&lt;/p&gt;

&lt;p&gt;この方法だと通信処理が走ってしまうのでサーバー負荷に加えて、結果が分かるのに時間もかかります。
そのため、クライアント側でバリデーションできたほうがUXとしては良いです。&lt;/p&gt;

&lt;p&gt;しかしクライアント側のバリデーションロジックとサーバ側の検証ロジックが完全一致していなければバグの温床となるため
クライアント側でバリデーションをするにしても最低限にとどまることが多いと思います。&lt;/p&gt;

&lt;p&gt;そのためあまり使うことが少ないのですが、少し考えてみました。&lt;/p&gt;

&lt;h2 id=&quot;validatorとvalidationresult-protocolの用意&quot;&gt;ValidatorとValidationResult protocolの用意&lt;/h2&gt;

&lt;p&gt;まずは執行役のValidator protocolとその結果を受け取るValidationResult protocolを用意します。&lt;/p&gt;

&lt;p&gt;Validatorには実行メソッドとなる&lt;code class=&quot;highlighter-rouge&quot;&gt;validate() -&amp;gt; ResultType&lt;/code&gt;を用意して、
Validator protocolの採用クラスはこのメソッドに検証処理をまとめます。&lt;/p&gt;

&lt;p&gt;そして、検証処理の結果としてValidationResult protocolを採用したクラスを返します。&lt;/p&gt;

&lt;p&gt;ValidationResultにはバリデーションが合格したか分かるようにisOkプロパティを用意します。&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mothule/498c37e2f78bc9a527d25df8c0dc615d.js?file=Validator.swift&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;名前バリデーションを作ってみる&quot;&gt;名前バリデーションを作ってみる&lt;/h2&gt;

&lt;p&gt;先程定義したValidatorとValidationResult protocolを使って名前用バリデーションを作ってみます。&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mothule/498c37e2f78bc9a527d25df8c0dc615d.js?file=NameValidator.swift&quot;&gt;&lt;/script&gt;

&lt;p&gt;ValidationResultをネストしても動かせるので型名をシンプルにできます。&lt;br /&gt;
ValidationResultの採用クラスをenumにしたことでバリデーションエラーの一覧が分かります&lt;/p&gt;

&lt;p&gt;また&lt;code class=&quot;highlighter-rouge&quot;&gt;tooLong(Int)&lt;/code&gt;のように内部パラメータを結果に渡すことでバリデーションエラーのハンドリング時に具体的な情報を構築することもできます。&lt;/p&gt;

&lt;h2 id=&quot;メールアドレスバリデーションを作ってみる&quot;&gt;メールアドレスバリデーションを作ってみる&lt;/h2&gt;

&lt;p&gt;今度はメールアドレス用バリデーションを作ってみます。&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mothule/498c37e2f78bc9a527d25df8c0dc615d.js?file=EmailValidator.swift&quot;&gt;&lt;/script&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;errorMessage: String&lt;/code&gt;のように起きたバリデーションエラーのメッセージテキストを&lt;strong&gt;デフォルト値&lt;/strong&gt;として使うこともできます。&lt;/p&gt;

&lt;h3 id=&quot;注意バリデーションのエラーメッセージをそのまま使うリスク&quot;&gt;注意：バリデーションのエラーメッセージをそのまま使うリスク&lt;/h3&gt;
&lt;p&gt;バリデーションは画面に結びついたものではなく検証対象に結びついたロジックです。&lt;br /&gt;
そのため1画面とは限りません。また表示する文言も1つとは限りません。&lt;br /&gt;
例えば男性と女声で文言を変える可能性もあれば、エラーした回数におうじて文言を変える可能性もあります。&lt;/p&gt;

&lt;p&gt;バリデーションのエラーメッセージを使う場合は、あくまでもデフォルト値として扱うようにしておき、&lt;br /&gt;
呼び出し元で上書き可能にしておくことで、デフォルトで良い部分はコード量を減らし、&lt;br /&gt;
必要に応じて上書きするコードを書けるといった仕組みにしておくことで柔軟性を維持しつつ楽できるようになります。&lt;/p&gt;

&lt;h2 id=&quot;バリデーションを使う&quot;&gt;バリデーションを使う&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-27-ios-swift-validation/1.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-27-ios-swift-validation/1.png&quot; width=&quot;100%&quot; alt=&quot;ViewControllerWithValidation&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;次は用意した2つのバリデーションをViewController側で使うコードです。&lt;br /&gt;
UIButtonの押下イベント内(&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchedRegister(_:)&lt;/code&gt;)で2つのUITextFieldからバリデーション処理を入れてます。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;errorMessage&lt;/code&gt;に文言が入ることで画面内にバリデーションエラーをユーザー通知します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-27-ios-swift-validation/2.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-27-ios-swift-validation/2.png&quot; width=&quot;50%&quot; alt=&quot;ValidationError&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mothule/498c37e2f78bc9a527d25df8c0dc615d.js?file=ViewController.swift&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;rnmovaliライブラリ&quot;&gt;RNMoValiライブラリ&lt;/h2&gt;
&lt;p&gt;実は昔モデル用バリデーションを作っています。
&lt;a href=&quot;https://github.com/mothule/RNMoVali&quot;&gt;mothule/RNMoVali&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これは1つのプロパティに、名前と用意してあるバリデーターを登録しておくことで、&lt;br /&gt;
バリデーション実行後に名前に紐づくバリデーション結果を受け取る仕組みです。&lt;/p&gt;

&lt;p&gt;しかし、記事冒頭に書いたようにあまりニーズがありません。&lt;br /&gt;
クライアント側で「しっかり」バリデーションを必要とするのは、サーバーのない登録系アプリぐらいで、&lt;br /&gt;
それらは大抵が個人が練習で作るToDoアプリぐらいでしょう。&lt;/p&gt;

&lt;p&gt;ちなみに作ったのが古いのでSwiftバージョンが古いですが、コンパイルエラーを直せば動くと思います。&lt;/p&gt;</content><author><name></name></author><category term="ios" /><category term="swift" /><summary type="html">アプリの入力フォームで無効なデータを登録しないようバリデーションを挟むことがあります。 大抵はAPI側で検証して問題があればバリデーションエラーとしてレスポンスを返し、 受け取ったクライアント側は結果をユーザーに伝えます。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-27-ios-swift-validation/0.png" /></entry><entry><title type="html">XcodeをApp Storeからダウンロードせず旧バージョンと共存させる</title><link href="https://blog.mothule.com/ios/xcode/ios-xcode-dl-old-version" rel="alternate" type="text/html" title="XcodeをApp Storeからダウンロードせず旧バージョンと共存させる" /><published>2020-05-20T00:00:00+09:00</published><updated>2020-05-20T20:25:16+09:00</updated><id>https://blog.mothule.com/ios/xcode/ios-xcode-dl-old-version</id><content type="html" xml:base="https://blog.mothule.com/ios/xcode/ios-xcode-dl-old-version">&lt;p&gt;プログラマーにとって最新版のみを最短で追従するのはリスキーです。&lt;/p&gt;

&lt;h2 id=&quot;旧バージョンのxcodeが必要な理由&quot;&gt;旧バージョンのXcodeが必要な理由&lt;/h2&gt;
&lt;p&gt;Xcodeはバージョン毎にSwiftの最低バージョンやiOSの最低バージョンが決まっており、
最新のバージョンだけだと、hotfix版のために古いSwiftバージョンなど直したいときにビルドが通らなくなるためです。&lt;/p&gt;

&lt;h3 id=&quot;例&quot;&gt;例&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;リリース日&lt;/th&gt;
      &lt;th&gt;App ver&lt;/th&gt;
      &lt;th&gt;Xcode ver&lt;/th&gt;
      &lt;th&gt;Swift ver&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1ヶ月前&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;10.3&lt;/td&gt;
      &lt;td&gt;4.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;開発中&lt;/td&gt;
      &lt;td&gt;1.1&lt;/td&gt;
      &lt;td&gt;11.0&lt;/td&gt;
      &lt;td&gt;5.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;アプリリース後にXcodeのバージョンを上げて、Swiftのバージョンアップ対応をしていたら、&lt;br /&gt;
最新リリース版で緊急のクラッシュバグが発生しました。&lt;br /&gt;
緊急のため開発中ブランチは一旦止めて、リリース版のrevisionから新しいブランチを切ってhotfix版としてリリースします。&lt;br /&gt;
しかしリリース版は、Xcode/Swiftバージョンが今より古いバージョンでリリースしたものです。&lt;br /&gt;
そのため、新しいバージョンではAPIが変わってたり、言語構文が変わったりしてビルドが通りません。&lt;/p&gt;

&lt;p&gt;このように最新版のXcodeだけだと、開発環境を再現ができないリスクがあります。&lt;/p&gt;

&lt;h2 id=&quot;app-storeからダウンロードしないほうがいい理由&quot;&gt;App Storeからダウンロードしないほうがいい理由&lt;/h2&gt;

&lt;p&gt;Xcode.appを一つしか使えなくなるためです。&lt;/p&gt;

&lt;p&gt;バージョンアップは手軽ですが、古いバージョンと最新バージョンをApplicationフォルダに共存させれなくなります。&lt;/p&gt;

&lt;h2 id=&quot;古いxcodeバージョンをダウンロードする&quot;&gt;古いXcodeバージョンをダウンロードする&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/download/more/&quot;&gt;More Downloads for Apple Developers&lt;/a&gt;(要ログイン)から過去バージョンをダウンロードできます。
また過去だけでなく最新バージョンやGM Seed版もダウンロードできます。&lt;/p&gt;

&lt;p&gt;xipファイルを解凍後はXcode.appをApplicationフォルダに移動する前に、既存のXcode.appをリネームさせます。&lt;br /&gt;
リネーム先は何でもいいですが、自分はバージョン番号をつけてます。&lt;/p&gt;

&lt;p&gt;既存バージョンが11.2.1だったら &lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode.app&lt;/code&gt; → &lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode11.2.1.app&lt;/code&gt;にリネームする。&lt;/p&gt;

&lt;p&gt;その後最新版Xcode.appをApplicationフォルダに移動させることで、最新版と旧版を共存させることができます。&lt;/p&gt;

&lt;p&gt;何世代まで残しておくかは自分が取り掛かっている案件特性に応じて計画してください。&lt;br /&gt;
私の今の環境では、1つ前のバージョンしか保持していません。&lt;br /&gt;
前の環境では、3つほど保持していました。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;App Storeではなく&lt;a href=&quot;https://developer.apple.com/download/more/&quot;&gt;More Downloads for Apple Developers&lt;/a&gt;からダウンロードする&lt;/li&gt;
  &lt;li&gt;古いXcode.appはリネームして何世代か持っておく&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="ios" /><category term="xcode" /><category term="mac" /><summary type="html">プログラマーにとって最新版のみを最短で追従するのはリスキーです。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-20-ios-xcode-dl-old-version/0.png" /></entry><entry><title type="html">コマンドラインからいい感じにXcodeプロジェクトを開くスクリプト作った</title><link href="https://blog.mothule.com/tools/tools-xcode-launcher-cli" rel="alternate" type="text/html" title="コマンドラインからいい感じにXcodeプロジェクトを開くスクリプト作った" /><published>2020-05-20T00:00:00+09:00</published><updated>2020-05-20T22:59:22+09:00</updated><id>https://blog.mothule.com/tools/tools-xcode-launcher-cli</id><content type="html" xml:base="https://blog.mothule.com/tools/tools-xcode-launcher-cli">&lt;p&gt;キータイプ数「open hoge.xcworkspace」を「&lt;strong&gt;xc&lt;/strong&gt;」にまで減らします。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;xcodeproj&lt;/code&gt;か&lt;code class=&quot;highlighter-rouge&quot;&gt;xcworkspace&lt;/code&gt;かいちいち確認不要になります。&lt;/p&gt;

&lt;p&gt;iOSエンジニアでもターミナルを使う頻度は非常に高いです。&lt;br /&gt;
そのためターミナル上からXcodeプロジェクトを開くことも多いです。&lt;/p&gt;

&lt;h2 id=&quot;ターミナルからxcodeプロジェクトを開く&quot;&gt;ターミナルからXcodeプロジェクトを開く&lt;/h2&gt;
&lt;p&gt;ターミナルからXcodeプロジェクトを開く場合は次のコマンドになります。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;open hoge.xcodeproj
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;しかしCocoaPodsを入れたりすると、xcodeprojではなく&lt;code class=&quot;highlighter-rouge&quot;&gt;xcworkspace&lt;/code&gt;を開く必要があります。&lt;br /&gt;
そのためターミナルでは次のコマンドになります。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;open hoge.xcworkspace
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;プロジェクト毎にxcodeprojなのかxcworkspaceなのかlsコマンドで確認するのは面倒です。&lt;br /&gt;
それが毎日来る日も来る日も、色々なプロジェクトをターミナルで開いているとますます面倒です。&lt;/p&gt;

&lt;h2 id=&quot;ターミナルからいい感じにxcodeプロジェクトを開くスクリプト&quot;&gt;ターミナルからいい感じにXcodeプロジェクトを開くスクリプト&lt;/h2&gt;
&lt;p&gt;ターミナルからXcodeプロジェクトを開く上でチリツモで面倒な作業なので勝手に判断して開くスクリプトを作りました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/mothule/xc_launcher&quot;&gt;mothule/xc_launcher&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-20-tools-xcode-launcher-cli/1.gif&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-20-tools-xcode-launcher-cli/1.gif&quot; width=&quot;100%&quot; alt=&quot;xcコマンドの動作&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;xcコマンドの使い方&quot;&gt;xcコマンドの使い方&lt;/h3&gt;
&lt;p&gt;使い方は簡単です。&lt;code class=&quot;highlighter-rouge&quot;&gt;xc&lt;/code&gt;コマンドを叩くことでカレントディレクトリからXcodeプロジェクトを見つけて起動します。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;your/xcode/proj/path
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;xc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ディレクトリパスを指定すれば別ディレクトリ内のXcodeプロジェクトを開こうとします。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;xc your/xcode/proj/path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;xcコマンドの特徴&quot;&gt;xcコマンドの特徴&lt;/h3&gt;
&lt;p&gt;このコマンドは次の特徴を持ってます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;xcodeprojとxcworkspaceがあればxcworkspaceを開く&lt;/li&gt;
  &lt;li&gt;Xcodeプロジェクトが複数あればAZ順の最初のXcodeプロジェクトを開く&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;インストール方法&quot;&gt;インストール方法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;1ファイルになっているのでファイルをGitHubから直接ダウンロード&lt;/li&gt;
  &lt;li&gt;chmod 711で実行権限付与&lt;/li&gt;
  &lt;li&gt;PATHの通った適当な場所にシンボリックリンクを引く&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;詳しくはGitHubページにも書いてあります。
&lt;a href=&quot;https://github.com/mothule/xc_launcher&quot;&gt;mothule/xc_launcher&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;iosエンジニアもスクリプトを書こう&quot;&gt;iOSエンジニアもスクリプトを書こう&lt;/h2&gt;

&lt;p&gt;今回スクリプトはRubyで書きました。&lt;br /&gt;
iOSエンジニアにとってRubyは身近な言語です。&lt;br /&gt;
fastlaneやCocoaPodsはRubyで書かれています。&lt;/p&gt;

&lt;p&gt;あなたもiOSエンジニアならRubyを覚えて、&lt;br /&gt;
身近な面倒くさいをスクリプトで解決して開発体験を向上させましょう。&lt;br /&gt;
なおRubyでスクリプトを書く場合は「&lt;span&gt;&lt;a href=&quot;/ruby/ruby-script-basic&quot;&gt;iOSエンジニアでもRubyでスクリプトを書いて時間のかかる手作業からの卒業&lt;/a&gt;&lt;/span&gt;
」の記事を参考にしてみてください。&lt;/p&gt;</content><author><name></name></author><category term="tools" /><category term="xcode" /><category term="ruby" /><summary type="html">キータイプ数「open hoge.xcworkspace」を「xc」にまで減らします。 xcodeprojかxcworkspaceかいちいち確認不要になります。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-20-tools-xcode-launcher-cli/eyecatch.png" /></entry><entry><title type="html">MacのHomebrewとは？仕組み・使い方と用語整理</title><link href="https://blog.mothule.com/mac/homebrew/mac-homebrew-basic" rel="alternate" type="text/html" title="MacのHomebrewとは？仕組み・使い方と用語整理" /><published>2020-05-18T00:00:00+09:00</published><updated>2020-05-19T00:46:04+09:00</updated><id>https://blog.mothule.com/mac/homebrew/mac-homebrew-basic</id><content type="html" xml:base="https://blog.mothule.com/mac/homebrew/mac-homebrew-basic">&lt;p&gt;便利だけど穴にハマると痛い目見て詰むパッケージ管理マネージャーです。&lt;/p&gt;

&lt;p&gt;インストールや使い方だけでなく、どのような仕組みでパッケージがインストールされているのか大まかな図式で説明します。&lt;/p&gt;

&lt;h2 id=&quot;homebrewとは&quot;&gt;Homebrewとは？&lt;/h2&gt;
&lt;p&gt;macOS用パッケージマネージャーです。&lt;br /&gt;
Macで使えるソフトウェア(パッケージ)の検索(search)、追加(install)、更新(update)、削除(uninstall)を司ります。
類似アプリにMacPortsがあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://brew.sh/&quot;&gt;Homebrew公式&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;homebrewのインストールと用語と仕組み&quot;&gt;Homebrewのインストールと用語と仕組み&lt;/h2&gt;

&lt;h3 id=&quot;インストール&quot;&gt;インストール&lt;/h3&gt;
&lt;p&gt;ターミナルを開いて次のコマンドを実行するとHomebrewのインストールが始まります。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/bin/bash &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; https://raw.githubusercontent.com/Homebrew/install/master/install.sh&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-18-mac-homebrew-basic/1.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-18-mac-homebrew-basic/1.png&quot; width=&quot;100%&quot; alt=&quot;Homebrew インストールフロー&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;用語&quot;&gt;用語&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Homebrew: home-brew(自家製ビール)&lt;/li&gt;
  &lt;li&gt;brew: (自動)醸造する, (名)ビール&lt;/li&gt;
  &lt;li&gt;Formula: 製法&lt;/li&gt;
  &lt;li&gt;Celler: 酒貯蔵室&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;仕組み&quot;&gt;仕組み&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Homebrew/brew&quot;&gt;Homebrew/brew&lt;/a&gt;からクライアントソフトをインストール
&lt;a href=&quot;https://github.com/Homebrew/homebrew-core/&quot;&gt;Homebrew/homebrew-core&lt;/a&gt;からFormulaをダウンロード
Formulaにはインストール手順が書いてあるため、それに従ってインストールされます。&lt;/p&gt;

&lt;p&gt;例えばnginxだと次のような手順書になっています。&lt;a href=&quot;https://github.com/Homebrew/homebrew-core/blob/master/Formula/nginx.rb&quot;&gt;homebrew-core/nginx.rb&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;インストールしたら&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/Celler&lt;/code&gt;に配置して、&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/bin&lt;/code&gt;にシンボリックリンクを貼ることでどこからでも呼べるようにします。&lt;/p&gt;

&lt;p&gt;「酒造方法が公開された様々な自家製ビールを製造して自分の酒貯蔵室に入れる」ってイメージです。&lt;/p&gt;

&lt;p&gt;ざっくり流れを表すとこんな感じです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-18-mac-homebrew-basic/2.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-18-mac-homebrew-basic/2.png&quot; width=&quot;100%&quot; alt=&quot;Homebrew formula install flow&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最後(6)のシンボリックリンクもHomebrewがやります。&lt;/p&gt;

&lt;h2 id=&quot;searchコマンド&quot;&gt;searchコマンド&lt;/h2&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;brew search [formula]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例えば&lt;code class=&quot;highlighter-rouge&quot;&gt;nginx&lt;/code&gt;で調べた場合です。&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew search nginx
&lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; Formulae
nginx ✔
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;infoコマンド&quot;&gt;infoコマンド&lt;/h2&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;brew info [formula...]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例えば&lt;code class=&quot;highlighter-rouge&quot;&gt;nginx&lt;/code&gt;の場合です。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew info nginx
nginx: stable 1.17.10 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;bottled&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, HEAD
HTTP&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; server and reverse proxy, and IMAP/POP3 proxy server
https://nginx.org/
/usr/local/Cellar/nginx/1.17.8 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;25 files, 2MB&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
  Poured from bottle on 2020-02-20 at 03:07:40
From: https://github.com/Homebrew/homebrew-core/blob/master/Formula/nginx.rb
&lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; Dependencies
Required: openssl@1.1 ✔, pcre ✔
&lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; Options
&lt;span class=&quot;nt&quot;&gt;--HEAD&lt;/span&gt;
	Install HEAD version
&lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; Caveats
Docroot is: /usr/local/var/www

The default port has been &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; /usr/local/etc/nginx/nginx.conf to 8080 so that
nginx can run without sudo.

nginx will load all files &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; /usr/local/etc/nginx/servers/.

To have launchd start nginx now and restart at login:
  brew services start nginx
Or,if you dont want/need a background service you can just run:
  nginx
  &lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; Analytics
install: 33,169 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;30 days&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 103,486 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;90 days&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 410,718 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;365 days&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
install-on-request: 32,184 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;30 days&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 100,197 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;90 days&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 394,782 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;365 days&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
build-error: 0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;30 days&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;この表示の元となる情報は&lt;a href=&quot;https://github.com/Homebrew/homebrew-core/blob/master/Formula/nginx.rb&quot;&gt;Formula&lt;/a&gt;になります。&lt;/p&gt;

&lt;h2 id=&quot;installコマンド&quot;&gt;installコマンド&lt;/h2&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;brew install [formula...]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;指定されたFormulaをインストールします。&lt;/p&gt;

&lt;p&gt;例えば&lt;code class=&quot;highlighter-rouge&quot;&gt;bash-completion&lt;/code&gt;の場合です。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew install bash-completion
Updating Homebrew...
&lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; Auto-updated Homebrew!
Updated Homebrew from 9fcaa46cd to ca5eac845.
Updated 2 taps &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;homebrew/core and homebrew/cask&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; New Formulae
erlang@22                                                    spotify-tui                                                  spotifyd
&lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; Updated Formulae
ffmpeg ✔            code-server         erlang              git-absorb          mariadb             opencv              pianobar            unpaper             yaws
x264 ✔              contentful-cli      ffmpeg2theora       gst-plugins-ugly    mgba                opencv@2            pipx                vapoursynth-sub
caffe               couchdb             ffmpeg@2.8          komposition         minidlna            opencv@3            qcli                vcs
cgns                dungeon             ffmpegthumbnailer   libav               mpd                 openimageio         scrcpy              whistle
chromaprint         ejabberd            ffms2               libwebsockets       mpv                 pdfsandwich         siril               wrangler
&lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; Updated Casks
cryo                                         graphicconverter                             mini-program-studio                          whalebird

&lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; Downloading https://homebrew.bintray.com/bottles/bash-completion-1.3_3.mojave.bottle.tar.gz
&lt;span class=&quot;c&quot;&gt;######################################################################## 100.0%&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; Pouring bash-completion-1.3_3.mojave.bottle.tar.gz
&lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; Caveats
Add the following line to your ~/.bash_profile:
  &lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/usr/local/etc/profile.d/bash_completion.sh&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/usr/local/etc/profile.d/bash_completion.sh&quot;&lt;/span&gt;

Bash completion has been installed to:
  /usr/local/etc/bash_completion.d
&lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; Summary
🍺  /usr/local/Cellar/bash-completion/1.3_3: 189 files, 607.8KB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;インストールした後に追加で必要な設定や追加のインストールなど重要な情報が載っている場合があります。
この場合は、&lt;code class=&quot;highlighter-rouge&quot;&gt;.bash_profile&lt;/code&gt;に処理を追加するよう書いてます。&lt;/p&gt;

&lt;h2 id=&quot;listlsコマンド&quot;&gt;list(ls)コマンド&lt;/h2&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;brew list&lt;/code&gt; または &lt;code class=&quot;highlighter-rouge&quot;&gt;brew ls&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;brew list&lt;/code&gt;または&lt;code class=&quot;highlighter-rouge&quot;&gt;brew ls&lt;/code&gt;でインストール済みのパッケージを確認します。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt;コマンド同様に&lt;code class=&quot;highlighter-rouge&quot;&gt;-l&lt;/code&gt;オプションを渡すことで縦に一覧化します。&lt;/p&gt;

&lt;h2 id=&quot;uninstallコマンド&quot;&gt;uninstallコマンド&lt;/h2&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;brew uninstall formula...&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Formulaをアンインストールします。&lt;/p&gt;

&lt;h2 id=&quot;outdatedコマンド&quot;&gt;outdatedコマンド&lt;/h2&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;brew outdated [formula...]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;新バージョン差異を確認する。&lt;br /&gt;
バージョン差異がなければ何も表示されない。
引数で&lt;code class=&quot;highlighter-rouge&quot;&gt;formula&lt;/code&gt;無指定だとインストールしている全てのformulaを対象。&lt;/p&gt;

&lt;h2 id=&quot;upgradeコマンド&quot;&gt;upgradeコマンド&lt;/h2&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;brew upgrade [formula...]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;formulaを新しいバージョンに更新する。
引数で&lt;code class=&quot;highlighter-rouge&quot;&gt;formula&lt;/code&gt;無指定だとインストールしている全てのformulaを対象。&lt;/p&gt;

&lt;h2 id=&quot;servicesコマンド群でlaunchd制御&quot;&gt;servicesコマンド群でlaunchd制御&lt;/h2&gt;
&lt;p&gt;自動起動の登録制御です。&lt;br /&gt;
インストールしたソフトウェアによっては自動起動をサポートするものもあります。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;services&lt;/code&gt;コマンド群はそれらを&lt;code class=&quot;highlighter-rouge&quot;&gt;launchctl&lt;/code&gt;コマンドや&lt;code class=&quot;highlighter-rouge&quot;&gt;~/Library/LaunchAgents&lt;/code&gt;ディレクトリにplistファイルを配置せずに
&lt;code class=&quot;highlighter-rouge&quot;&gt;services start&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;stop&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;コマンドを使って&lt;code class=&quot;highlighter-rouge&quot;&gt;launchd&lt;/code&gt;デーモンを制御できるようになります。&lt;/p&gt;

&lt;h3 id=&quot;services-startコマンド&quot;&gt;services startコマンド&lt;/h3&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;brew services start formula&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;渡したコマンドを自動起動します。&lt;/p&gt;

&lt;p&gt;例えば&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql@5.6&lt;/code&gt;formulaを&lt;code class=&quot;highlighter-rouge&quot;&gt;brew info&lt;/code&gt;で見ると次のように案内があります。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;To have launchd start mysql@5.6 now and restart at login:
  brew services start mysql@5.6
Or, if you don't want/need a background service you can just run:
  /usr/local/opt/mysql@5.6/bin/mysql.server start
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql.server start&lt;/code&gt;コマンドでMySQLサーバーをその都度起動するか、
もしくは、&lt;code class=&quot;highlighter-rouge&quot;&gt;brew services start mysql@5.6&lt;/code&gt;コマンドで自動起動させるか方法を提示してます。&lt;/p&gt;

&lt;h3 id=&quot;services-listコマンド&quot;&gt;services listコマンド&lt;/h3&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;brew services list&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;現在自動起動中になっているformula一覧を確認します。&lt;/p&gt;

&lt;p&gt;例えば手元のPCだとこうなります。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew services &lt;span class=&quot;nb&quot;&gt;ls
&lt;/span&gt;Name                       Status  User    Plist
mysql@5.6                  stopped
nginx                      started mothule /Users/mothule/Library/LaunchAgents/homebrew.mxcl.nginx.plist
php                        started mothule /Users/mothule/Library/LaunchAgents/homebrew.mxcl.php.plist
postgresql                 started mothule /Users/mothule/Library/LaunchAgents/homebrew.mxcl.postgresql.plist
redis                      started mothule /Users/mothule/Library/LaunchAgents/homebrew.mxcl.redis.plist
selenium-server-standalone started mothule /Users/mothule/Library/LaunchAgents/homebrew.mxcl.selenium-server-standalone.plist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;services-stopコマンド&quot;&gt;services stopコマンド&lt;/h3&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;brew services stop formula&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;自動起動を解除します。&lt;/p&gt;

&lt;p&gt;先程のnginxの自動起動を止めた場合です。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew services stop nginx
Stopping &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;nginx&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;... &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;might take a &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;==&amp;gt;&lt;/span&gt; Successfully stopped &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;nginx&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;label: homebrew.mxcl.nginx&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;services-runコマンド&quot;&gt;services runコマンド&lt;/h3&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;brew services run formula&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;自動起動の登録せずにサービスとして起動します。&lt;/p&gt;

&lt;h2 id=&quot;homebrew-caskでguiアプリの制御&quot;&gt;Homebrew caskでGUIアプリの制御&lt;/h2&gt;
&lt;p&gt;紹介したコマンドに&lt;code class=&quot;highlighter-rouge&quot;&gt;brew&lt;/code&gt;とコマンドの間に&lt;code class=&quot;highlighter-rouge&quot;&gt;cask&lt;/code&gt;を入れるとGUIアプリケーションの制御となります。&lt;br /&gt;
caskとはお酒を入れる木製の大樽です。&lt;/p&gt;

&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;brew cask commands ...&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;つまりこういうことです。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;brew cask search formula&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;brew cask info formula&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;brew cask install formula&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;brew cask list&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;brew cask uninstall&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;brew cask outdated&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;brew cask upgrade&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;keg-onlyとは&quot;&gt;keg-onlyとは&lt;/h2&gt;
&lt;p&gt;時折brew infoなどで&lt;code class=&quot;highlighter-rouge&quot;&gt;keg-only&lt;/code&gt;という単語を見かけます。&lt;/p&gt;

&lt;p&gt;例えば&lt;code class=&quot;highlighter-rouge&quot;&gt;brew info mysql@5.6&lt;/code&gt;にも&lt;code class=&quot;highlighter-rouge&quot;&gt;key-only&lt;/code&gt;とあります。
これは大抵が上書きリスクのあるformulaについてます。
例えばMacに標準インストールされているコマンドのGNU版などです。&lt;/p&gt;

&lt;p&gt;これはインストールして&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/Celler&lt;/code&gt;に配置まではしたが、&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/bin&lt;/code&gt;へシンボリックリンクを繋いでいない状態です。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;brew link&lt;/code&gt;することでリンクされて使えるようになります。&lt;br /&gt;
しかし、既存コマンドのパスが変わる可能性が高いので、慎重に行うことを推奨します。&lt;/p&gt;

&lt;h2 id=&quot;formulaが見つからない&quot;&gt;formulaが見つからない&lt;/h2&gt;
&lt;p&gt;手元のhomebrewが古い可能性があります。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;brew update&lt;/code&gt;で更新することで見つかるかもしれません。&lt;/p&gt;

&lt;p&gt;しかし、手元の古いバージョンは破棄することがあるので、&lt;br /&gt;
今まで偶然残っていたお陰で動いてたコマンドがバージョンが最新のみになったことでパスが通らなくなり知らぬところでエラーが発生することもあるので注意が必要です。&lt;/p&gt;

&lt;h2 id=&quot;再インストール&quot;&gt;再インストール&lt;/h2&gt;
&lt;p&gt;インストール済みのソフトウェアが何かの拍子におかしくなった場合、&lt;br /&gt;
再インストールを促されることがあります。&lt;br /&gt;
Homebrewの場合は&lt;code class=&quot;highlighter-rouge&quot;&gt;brew reinstall&lt;/code&gt;コマンドがあります。&lt;/p&gt;

&lt;h2 id=&quot;tapってコマンドが出てきた&quot;&gt;tapってコマンドが出てきた&lt;/h2&gt;
&lt;p&gt;デフォルトのformula一覧とは別の場所からformulaを取ってきたい場合に使うコマンドです。&lt;br /&gt;
この&lt;code class=&quot;highlighter-rouge&quot;&gt;tap&lt;/code&gt;コマンドを使うことでタップした先からもformulaをインストールすることが出来ます。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;tap&lt;/code&gt;とは蛇口です。樽に蛇口を差し込んだイメージが丁度いいです。&lt;/p&gt;

&lt;h2 id=&quot;基本は簡単だけど運用は難しい&quot;&gt;基本は簡単だけど運用は難しい&lt;/h2&gt;
&lt;p&gt;Homebrewの説明は以上です。ある程度網羅かつシンプルな説明にはなっていますが、
実際に使っていくと最初はよくても後半の方で色々とformulaの依存関係が衝突を起こしたりして
自力で解決を迫られることが多くあります。
&lt;strong&gt;何気なくbrew upgrade&lt;/strong&gt; を実行したら色々なformulaが最新化されて、&lt;br /&gt;
それを使ってた物が動かなくなるなんてことは普通にあります…&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OpenSSLのバージョンが変わって旧バージョンのパスが消えたRubyが動かなくなる「&lt;span&gt;&lt;a href=&quot;/tools/rbenv/tools-rbenv-ssl-load-error&quot;&gt;OpenSSL Library not loadedが出たら疑う場所&lt;/a&gt;&lt;/span&gt;
」&lt;/li&gt;
  &lt;li&gt;readlineの更新でtigが動かなくなった「&lt;span&gt;&lt;a href=&quot;/mac/homebrew/mac-homebrew-how-to-downgrade&quot;&gt;Homebrewで過去バージョンにダウングレードする2つの方法&lt;/a&gt;&lt;/span&gt;
」&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;など他にも記事にはしてませんが、Pythonのバージョンにより&lt;a href=&quot;https://blog.mothule.com/tools/httpie/recommend-httpie&quot;&gt;HTTPie&lt;/a&gt;が動かなくなる件など。&lt;/p&gt;

&lt;p&gt;brewは便利なパッケージ管理マネージャーですが、扱っているパッケージ(コマンド)のインストール先や呼び出される仕組みを理解しておかないと、
シェルコマンドはパスという糸つなぎのようなものなので、自力で追いかけられなくなります。&lt;/p&gt;</content><author><name></name></author><category term="mac" /><category term="homebrew" /><summary type="html">便利だけど穴にハマると痛い目見て詰むパッケージ管理マネージャーです。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-18-mac-homebrew-basic/eyecatch.png" /></entry><entry><title type="html">ln -sでシンボリックリンクを作る</title><link href="https://blog.mothule.com/tools/ln/tools-ln-guide" rel="alternate" type="text/html" title="ln -sでシンボリックリンクを作る" /><published>2020-05-18T00:00:00+09:00</published><updated>2020-05-18T20:02:14+09:00</updated><id>https://blog.mothule.com/tools/ln/tools-ln-guide</id><content type="html" xml:base="https://blog.mothule.com/tools/ln/tools-ln-guide">&lt;p&gt;Windowsでいうショートカットに似た何か。&lt;/p&gt;

&lt;h2 id=&quot;ln--sでシンボリックリンクを構築&quot;&gt;ln -sでシンボリックリンクを構築&lt;/h2&gt;

&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;ln -s リンク対象パス リンク作成先のディレクトリパス&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;自分の中で「リンク」ってワードが邪魔して&lt;br /&gt;
src/destどっちがどっちか分からなくなることが頻発する。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ln &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; ~/オレの/最強の/凄いコマンド /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;ls--lでシンボリックを確認&quot;&gt;ls -lでシンボリックを確認&lt;/h2&gt;

&lt;p&gt;シンボリックリンクはファイル名とリンク先が「&lt;code class=&quot;highlighter-rouge&quot;&gt;name -&amp;gt; original path&lt;/code&gt;」形式で表示されます。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ln &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; ~/オレの/最強の/凄いコマンド /usr/local/bin/
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; /usr/local/bin/
凄いコマンド -&amp;gt; ~/オレの/最強の/凄いコマンド
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;unlinkでシンボリックリンクを解除&quot;&gt;unlinkでシンボリックリンクを解除&lt;/h2&gt;

&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;unlink シンボリックのパス&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;unlink /usr/local/bin/使い物にならない自作コマンド
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;せめて&lt;code class=&quot;highlighter-rouge&quot;&gt;ln -d&lt;/code&gt;とかにしてほしかったな。&lt;/p&gt;</content><author><name></name></author><category term="tools" /><category term="ln" /><summary type="html">Windowsでいうショートカットに似た何か。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-18-tools-ln-guide/0.png" /></entry><entry><title type="html">ターミナルからRubyMineを起動、比較、マージなどする</title><link href="https://blog.mothule.com/tools/rubymine/tools-rubymine-launch-from-terminal" rel="alternate" type="text/html" title="ターミナルからRubyMineを起動、比較、マージなどする" /><published>2020-05-18T00:00:00+09:00</published><updated>2020-05-18T18:36:28+09:00</updated><id>https://blog.mothule.com/tools/rubymine/tools-rubymine-launch-from-terminal</id><content type="html" xml:base="https://blog.mothule.com/tools/rubymine/tools-rubymine-launch-from-terminal">&lt;p&gt;RubyMineは便利ですが、普段はターミナルを触ることが多いので、ターミナルからRubyMineを開く方法について調べたら、開く以外のことができることが分かったのでまとめます。&lt;/p&gt;

&lt;h2 id=&quot;ターミナルからrubymineで開く&quot;&gt;ターミナルからRubyMineで開く&lt;/h2&gt;

&lt;p&gt;まずターミナルからRubyMine.appwを開くには&lt;code class=&quot;highlighter-rouge&quot;&gt;open&lt;/code&gt;コマンドを使います。
最後のドットはそのフォルダをRubyMineで開くことを意味します。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;open &lt;span class=&quot;nt&quot;&gt;-na&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;RubyMine.app&quot;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;-a : アプリケーションを指定する&lt;/li&gt;
  &lt;li&gt;-n : アプリが起動済みでも新しいインスタンスで開く&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;シェルスクリプト化する&quot;&gt;シェルスクリプト化する&lt;/h2&gt;

&lt;h3 id=&quot;シェルスクリプトを用意&quot;&gt;シェルスクリプトを用意&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
open &lt;span class=&quot;nt&quot;&gt;-na&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;RubyMine.app&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--args&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$@&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;これを&lt;code class=&quot;highlighter-rouge&quot;&gt;rubymine&lt;/code&gt;という名前で保存します。&lt;/p&gt;

&lt;h3 id=&quot;実行権限付与&quot;&gt;実行権限付与&lt;/h3&gt;
&lt;p&gt;さっき作ったシェルスクリプトの実行権限を変更します&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;chmod 711 rubymine
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;これでターミナルからrubymineスクリプトを実行できるようになります。&lt;/p&gt;

&lt;h3 id=&quot;パスが見えるようにする&quot;&gt;パスが見えるようにする&lt;/h3&gt;

&lt;p&gt;このままだと配置した場所のパスが必要になるので、ターミナルが見えるようにパスが見える場所に配置します。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mv rubymine /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;なおこの場所でなくとも&lt;code class=&quot;highlighter-rouge&quot;&gt;cat $PATH&lt;/code&gt;で表示されるディレクトリ上にならどこでも構いません。&lt;/p&gt;

&lt;h3 id=&quot;rubymineに渡せる引数一覧&quot;&gt;RubyMineに渡せる引数一覧&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;引数なし : RubyMine起動&lt;/li&gt;
  &lt;li&gt;ファイルまたはディレクトリのパス : RubyMineで指定パスを開きます&lt;/li&gt;
  &lt;li&gt;diff : 渡された２つのファイルの差分を見ます&lt;/li&gt;
  &lt;li&gt;merge : 渡されたファイル2~3つと出力パスでマージします&lt;/li&gt;
  &lt;li&gt;format : 指定されたファイルにコードスタイルのフォーマットを適用します&lt;/li&gt;
  &lt;li&gt;inspect : 指定プロジェクトでコード検査します&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rubymineでファイル差分を見る&quot;&gt;RubyMineでファイル差分を見る&lt;/h2&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;rubymine diff &amp;lt;path1&amp;gt; &amp;lt;path2&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hoge&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; hoge.txt
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Fuga&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; fuga.txt
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rubymine diff hoge.txt fuga.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-18-tools-rubymine-launch-from-terminal/1.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-18-tools-rubymine-launch-from-terminal/1.png&quot; width=&quot;100%&quot; alt=&quot;RubyMine diff画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;rubymineでファイルマージする&quot;&gt;RubyMineでファイルマージする&lt;/h2&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;rubymine merge &amp;lt;path1&amp;gt; &amp;lt;path2&amp;gt; [&amp;lt;base&amp;gt;] &amp;lt;output&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hoge&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; hoge.txt
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Fuga&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; fuga.txt
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;touch base.txt
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;touch out.txt
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rubymine diff hoge.txt fuga.txt base.txt out.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-18-tools-rubymine-launch-from-terminal/2.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-18-tools-rubymine-launch-from-terminal/2.png&quot; width=&quot;100%&quot; alt=&quot;RubyMine merge画面&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;rubymineでファイルフォーマットを適用する&quot;&gt;RubyMineでファイルフォーマットを適用する&lt;/h2&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;rubymine format [&amp;lt;options&amp;gt;] &amp;lt;path ...&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;ruby.rb
def main
puts &lt;span class=&quot;s2&quot;&gt;&quot;hogehogehoge&quot;&lt;/span&gt;
end
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rubymine ruby.rb
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;ruby.rb
def main
  puts &lt;span class=&quot;s2&quot;&gt;&quot;hogehogehoge&quot;&lt;/span&gt;
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;どうやらrubocopが動くようではなく、RubyMine内の設定(Editor ｜ Code Style)に沿うようです。&lt;/p&gt;

&lt;h3 id=&quot;options&quot;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;-h : ヘルプ表示&lt;/li&gt;
  &lt;li&gt;-m or -mask : コンマ区切りでマスクファイルの一覧
    &lt;ul&gt;
      &lt;li&gt;例 : -m &lt;em&gt;.xml,&lt;/em&gt;.html&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;-r or -R : 階層処理&lt;/li&gt;
  &lt;li&gt;-s or -settings : ExportされたRubyMine内の設定&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rubymineでコード検査する&quot;&gt;RubyMineでコード検査する&lt;/h2&gt;
&lt;p&gt;Syntax: &lt;code class=&quot;highlighter-rouge&quot;&gt;rubymine inspect &amp;lt;project&amp;gt; &amp;lt;inspection-profile&amp;gt; &amp;lt;output&amp;gt; [&amp;lt;options&amp;gt;]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;RubyMineでコード書いていると警告されるアレです。&lt;br /&gt;
ターミナル上からコード検査をして結果を外部ファイルに出力します。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/Downloads/sandbox&lt;/code&gt;ディレクトリがあり、その中に&lt;code class=&quot;highlighter-rouge&quot;&gt;ruby.rb&lt;/code&gt;ファイルがあった場合&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rubymine inspect ~/Downloads/sandbox/ ~/Downloads/sandbox/.idea/inspectionProfiles/Project_Default.xml ~/Downloads/sandbox/InspectionResults &lt;span class=&quot;nt&quot;&gt;-v2&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; ~/Downloads/sandbox/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;options-1&quot;&gt;Options&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;-d : 検査ディレクトリの指定.&lt;/li&gt;
  &lt;li&gt;-format : 結果フォーマットの指定(xml/json/plan). デフォはxml&lt;/li&gt;
  &lt;li&gt;v : 検査詳細レベル
    &lt;ul&gt;
      &lt;li&gt;-v0 : デフォルト(最も低い)&lt;/li&gt;
      &lt;li&gt;-v1 : ミディオム&lt;/li&gt;
      &lt;li&gt;-v2 : 最大&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;diffとmergeがあるのは知りませんでした。&lt;br /&gt;
渡せる引数からしてgit mergetoolに登録できるかもしれません。&lt;br /&gt;
もし渡せたら重いp4mergeとはオサラバです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jetbrains.com/help/ruby/working-with-the-ide-features-from-command-line.html&quot;&gt;RubyMine - Command-line interface&lt;/a&gt;を参考にしてあります。
なお公式記事内では &lt;code class=&quot;highlighter-rouge&quot;&gt;inspect&lt;/code&gt; が &lt;code class=&quot;highlighter-rouge&quot;&gt;rinspect&lt;/code&gt; となっています。&lt;code class=&quot;highlighter-rouge&quot;&gt;rinspect&lt;/code&gt;では動かなかったので多分タイポです。&lt;/p&gt;</content><author><name></name></author><category term="tools" /><category term="rubymine" /><summary type="html">RubyMineは便利ですが、普段はターミナルを触ることが多いので、ターミナルからRubyMineを開く方法について調べたら、開く以外のことができることが分かったのでまとめます。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-18-tools-rubymine-launch-from-terminal/eyecatch.png" /></entry><entry><title type="html">CarthageのCartfileの書き方と個別更新方法</title><link href="https://blog.mothule.com/ios/carthage/ios-carthage-cartfile-format" rel="alternate" type="text/html" title="CarthageのCartfileの書き方と個別更新方法" /><published>2020-05-17T00:00:00+09:00</published><updated>2020-05-17T18:54:56+09:00</updated><id>https://blog.mothule.com/ios/carthage/ios-carthage-cartfile-format</id><content type="html" xml:base="https://blog.mothule.com/ios/carthage/ios-carthage-cartfile-format">&lt;p&gt;Podfileと書き方が微妙に異なるので注意です。カンマは使いません。&lt;/p&gt;

&lt;p&gt;ライブラリを導入したら新しいバージョンが公開されたら追従しなければいけません。
この記事ではCarthageで管理してるライブラリのバージョン追従方法について説明します。&lt;/p&gt;

&lt;h2 id=&quot;cartfileでバージョンを指定する&quot;&gt;Cartfileでバージョンを指定する&lt;/h2&gt;

&lt;p&gt;例えばCartfileでは次のようにライブラリのバージョンを指定することができます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;github &quot;SwiftyJSON&quot; ~&amp;gt; 4.2.0
github &quot;Hoge&quot; &amp;gt;= 4.2.0
github &quot;Fuga&quot; == 4.2.0
github &quot;Nuga&quot; &quot;develop&quot;
github &quot;Moga&quot; &quot;ab12c3ef4&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;それぞれ順に説明していきます。&lt;/p&gt;

&lt;h3 id=&quot;で範囲指定する&quot;&gt;~&amp;gt;で範囲指定する&lt;/h3&gt;
&lt;p&gt;最も多く使われてるであろう書き方です。
例えばバージョン履歴が下記だった場合で説明します。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;4.2.0&lt;/li&gt;
  &lt;li&gt;4.2.1&lt;/li&gt;
  &lt;li&gt;4.3.0&lt;/li&gt;
  &lt;li&gt;5.0.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このときにCartfileで&lt;code class=&quot;highlighter-rouge&quot;&gt;github &quot;Hoge&quot; ~&amp;gt; 4.2.0&lt;/code&gt;が記入された状態で&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt;を実行したら&lt;code class=&quot;highlighter-rouge&quot;&gt;4.2.1&lt;/code&gt;までアップデートします。&lt;br /&gt;
もし&lt;code class=&quot;highlighter-rouge&quot;&gt;github &quot;Hoge&quot; ~&amp;gt; 4.2&lt;/code&gt;が記入されてたら&lt;code class=&quot;highlighter-rouge&quot;&gt;4.3.0&lt;/code&gt;までアップデートします。&lt;/p&gt;

&lt;p&gt;なかなか範囲が覚えにくいと思いますが、最後の数字が&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;に置き換えて見れば分かりやすくなります。&lt;br /&gt;
例えば &lt;code class=&quot;highlighter-rouge&quot;&gt;github &quot;Hoge&quot; ~&amp;gt; 4.2.0&lt;/code&gt;であれば&lt;code class=&quot;highlighter-rouge&quot;&gt;4.2.x&lt;/code&gt;系です。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;4.2&lt;/code&gt;なら&lt;code class=&quot;highlighter-rouge&quot;&gt;4.x&lt;/code&gt;系です。つまり4系バージョンですね。&lt;/p&gt;

&lt;h3 id=&quot;-で指定バージョン以上&quot;&gt;&amp;gt;= で指定バージョン以上&lt;/h3&gt;

&lt;p&gt;指定バージョン値以上のバージョンを指定します。&lt;br /&gt;
Cartfileに&lt;code class=&quot;highlighter-rouge&quot;&gt;github &quot;Hoge&quot; &amp;gt;= 4.2.1&lt;/code&gt;と記入された状態で&lt;br /&gt;
バージョン履歴が下記だった場合は、&lt;code class=&quot;highlighter-rouge&quot;&gt;5.0.0&lt;/code&gt;がインストールされます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;4.2.0&lt;/li&gt;
  &lt;li&gt;4.2.1&lt;/li&gt;
  &lt;li&gt;4.3.0&lt;/li&gt;
  &lt;li&gt;5.0.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この書き方は少し破壊変更リスクが伴うため使う側としてはオススメしないです。&lt;br /&gt;
こっちよりも前述した範囲指定のほうが安全性をそれなりに維持できます。&lt;/p&gt;

&lt;h3 id=&quot;-で指定バージョンのみ&quot;&gt;== で指定バージョンのみ&lt;/h3&gt;

&lt;p&gt;もっとも安全なバージョン指定方法です。&lt;br /&gt;
Cartfileに&lt;code class=&quot;highlighter-rouge&quot;&gt;github &quot;Hoge&quot; == 4.2.1&lt;/code&gt;と記入されていたら&lt;br /&gt;
他にバージョンが出ていても &lt;code class=&quot;highlighter-rouge&quot;&gt;4.2.1&lt;/code&gt;しかインストールされません。&lt;/p&gt;

&lt;p&gt;丁寧にバージョンアップをしたいライブラリや開発運用に適した方法です。&lt;/p&gt;

&lt;h3 id=&quot;revisionでコミット指定&quot;&gt;revisionでコミット指定&lt;/h3&gt;

&lt;p&gt;GitHub上のコミットを名指しでインストールします。コミットで発行されているrevisionを使います。&lt;br /&gt;
またrevisionだけでなくブランチ名でも使えます。&lt;/p&gt;

&lt;p&gt;使っていたライブラリに不具合や脆弱性、iOS最新版が出たけどライブラリ側がバージョンを切っていない状態など&lt;br /&gt;
緊急時で使うことがあるので覚えておいたほうがいいです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Carthage/Carthage/blob/master/Documentation/Artifacts.md#version-requirement&quot;&gt;Carthage公式のVersion requirement&lt;/a&gt;でも英語ですが説明セクションはあります。&lt;/p&gt;

&lt;h2 id=&quot;ライブラリの個別更新&quot;&gt;ライブラリの個別更新&lt;/h2&gt;
&lt;p&gt;更新したいライブラリをCartfileに書いて&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;を実行すると、更新不要なライブラリも更新対象となります。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthge update&lt;/code&gt;ではライブラリ名を渡せばそのライブラリのみを更新してくれます。
SwiftyJSONのみを更新する場合&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;carthage update SwiftyJSON &lt;span class=&quot;nt&quot;&gt;--platform&lt;/span&gt; iOS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;ビルド済みライブラリのスキップ&quot;&gt;ビルド済みライブラリのスキップ&lt;/h2&gt;
&lt;p&gt;先程と同じテーマですが、&lt;code class=&quot;highlighter-rouge&quot;&gt;--cache-builds&lt;/code&gt;オプションを渡すことでビルド済みのライブラリの場合はスキップしてくれます。
この場合は個別でライブラリ名を指定は必要ありません。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;carthage update &lt;span class=&quot;nt&quot;&gt;--platform&lt;/span&gt; iOS &lt;span class=&quot;nt&quot;&gt;--cache-builds&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;もっと体系的に理解する&quot;&gt;もっと体系的に理解する&lt;/h2&gt;

&lt;p&gt;この記事では、記事の読みやすいよう導入に絞ってます。
もしチーム運用、git管理、CocoaPodsとの違いなど使い続けたら必要になる部分は別記事に分けており、&lt;br /&gt;
「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage&quot;&gt;Carthageの使い方を体系的に理解する&lt;/a&gt;&lt;/span&gt;
」からまとめて知ることができます。&lt;/p&gt;</content><author><name></name></author><category term="ios" /><category term="carthage" /><summary type="html">Podfileと書き方が微妙に異なるので注意です。カンマは使いません。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-17-ios-carthage-cartfile-format/0.png" /></entry><entry><title type="html">Carthage bootstrapとGit管理をチーム運用観点で整理</title><link href="https://blog.mothule.com/ios/carthage/ios-carthage-team-collaboration" rel="alternate" type="text/html" title="Carthage bootstrapとGit管理をチーム運用観点で整理" /><published>2020-05-15T00:00:00+09:00</published><updated>2020-05-17T18:54:56+09:00</updated><id>https://blog.mothule.com/ios/carthage/ios-carthage-team-collaboration</id><content type="html" xml:base="https://blog.mothule.com/ios/carthage/ios-carthage-team-collaboration">&lt;p&gt;この記事ではcarthage bootstrapとは何か？Git管理はどうするか？をチーム運用観点でこれら関係性を整理します。&lt;/p&gt;

&lt;h2 id=&quot;carthage-updateとbootstrapの違い&quot;&gt;carthage updateとbootstrapの違い&lt;/h2&gt;
&lt;p&gt;carthage bootstrapについて説明します。&lt;/p&gt;

&lt;p&gt;説明には、carthage bootstrapと比較するコマンドや関係するファイルを用いて説明します。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;carthage updateは&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile&lt;/code&gt;を見てframeworkと&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile.resolved&lt;/code&gt;を作成する&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile.resolved&lt;/code&gt;は実際に作成したframeworkの&lt;code class=&quot;highlighter-rouge&quot;&gt;ライブラリ&lt;/code&gt;と&lt;code class=&quot;highlighter-rouge&quot;&gt;バージョン&lt;/code&gt;が記載されてる&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage bootstrap&lt;/code&gt;は&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile.resolved&lt;/code&gt;を見てframeworkを作成する&lt;/li&gt;
  &lt;li&gt;carthage updateは&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile&lt;/code&gt;を見て&lt;strong&gt;なるべく最新&lt;/strong&gt;のライブラリバージョンを選ぶ&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1、2、3をイメージで説明します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-15-ios-carthage-team-collaboration/1.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-15-ios-carthage-team-collaboration/1.png&quot; width=&quot;100%&quot; alt=&quot;Carthageのupdateとbootstrapの違い&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;carthage updateはCartfileを使ってCartfile.resolvedとフレームワークを更新します。&lt;/li&gt;
  &lt;li&gt;carthage bootstrapはCartfile.resolvedを使ってフレームワークを更新します。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そして最も大きな違いは、&lt;strong&gt;carthage updateには冪等性がなく、carthage bootstrapには冪等性がある点です。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;carthage-updateの動き&quot;&gt;carthage updateの動き&lt;/h3&gt;
&lt;p&gt;例えば、carthage updateを5月1日に実行して、SwiftyJSON ver4のframeworkが作成されます。&lt;br /&gt;
半月後にSwiftyJSONが新しいバージョンver5をリリースします。&lt;br /&gt;
更に&lt;strong&gt;半月後にもう一度carthage updateを実行すると、SwiftyJSON ver5のframeworkが作成されます。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-15-ios-carthage-team-collaboration/2.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-15-ios-carthage-team-collaboration/2.png&quot; width=&quot;100%&quot; alt=&quot;Carthage updateの動き&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;つまり、&lt;strong&gt;carthage updateはライブラリ更新をします。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;carthage-bootstrapの動き&quot;&gt;carthage bootstrapの動き&lt;/h3&gt;
&lt;p&gt;updateではなくbootstrapですると、&lt;br /&gt;
1ヶ月後でもframeworkのバージョンは変わりません。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-15-ios-carthage-team-collaboration/3.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-15-ios-carthage-team-collaboration/3.png&quot; width=&quot;100%&quot; alt=&quot;Carthage updateの動き&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;つまり、&lt;strong&gt;carthage updateは環境を再現します。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;carthage-updateとbootstrapの使い分け&quot;&gt;carthage updateとbootstrapの使い分け&lt;/h3&gt;

&lt;p&gt;ライブラリの新規・更新はupdate、環境構築はbootstrapとして使います。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;updateを使うケース
    &lt;ul&gt;
      &lt;li&gt;ライブラリを追加する&lt;/li&gt;
      &lt;li&gt;ライブラリのバージョンを上げる&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;bootstrapを使うケース
    &lt;ul&gt;
      &lt;li&gt;新しくチームメンバーが入ってきて、開発環境を構築する&lt;/li&gt;
      &lt;li&gt;別メンバーがライブラリのバージョンを更新した&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;carthageとgit管理&quot;&gt;CarthageとGit管理&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;で&lt;code class=&quot;highlighter-rouge&quot;&gt;Carghage&lt;/code&gt;ディレクトリと&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage.resolved&lt;/code&gt;ファイルが生成されますが、&lt;br /&gt;
これらはGit管理下に加えるべきでしょうか？除外すべきでしょうか？&lt;/p&gt;

&lt;p&gt;方法は2つあります。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile.resolved&lt;/code&gt;だけをGit管理下において、&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage bootstrap&lt;/code&gt;で&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage&lt;/code&gt;ディレクトリを再現する方法と、&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile.resolved&lt;/code&gt;と&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage&lt;/code&gt;ディレクトリの両方をGit管理下においてgit cloneだけで再現環境を実現する方法です。&lt;/p&gt;

&lt;h3 id=&quot;cartfileresolvedのみをgit管理下にする&quot;&gt;Cartfile.resolvedのみをGit管理下にする&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile.resolved&lt;/code&gt;はライブラリ名とそれらのバージョンが記載されたファイルであることは説明しました。&lt;br /&gt;
しかし&lt;code class=&quot;highlighter-rouge&quot;&gt;framework&lt;/code&gt;はないので、&lt;code class=&quot;highlighter-rouge&quot;&gt;carthge bootstrap&lt;/code&gt;コマンドを使って必要なframeworkを構築します。&lt;/p&gt;

&lt;h3 id=&quot;cartfileresolvedとcarthageディレクトリ&quot;&gt;Cartfile.resolvedとCarthageディレクトリ&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile.resolved&lt;/code&gt;は他環境で再現をする上で必要です。&lt;br /&gt;
そこに加えて、&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage&lt;/code&gt;ディレクトリがあることで、frameworkの生成が不要になります。&lt;/p&gt;

&lt;h4 id=&quot;buildのみにする&quot;&gt;Buildのみにする&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage&lt;/code&gt;ディレクトリ全てをGit管理下不要です。&lt;br /&gt;
必要なのは生成済みframeworkなのため、&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage/Build&lt;/code&gt;ディレクトリのみで問題ありません。&lt;/p&gt;

&lt;p&gt;そのため&lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt;に追記が必要です。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Carthage/Checkouts
!Carthage/Build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;どちらがいいのか&quot;&gt;どちらがいいのか？&lt;/h3&gt;
&lt;p&gt;これは議論されているので、どちらがいいのか確定的なものはありません。&lt;br /&gt;
答えとしては案件によります。&lt;br /&gt;
なのでネットで「こちらがいい」と書いてあっても鵜呑みは危険です。&lt;br /&gt;
理由を見てそれが自分が適用しようとしてる条件に一致しているか判断することを進めます。&lt;/p&gt;

&lt;p&gt;ここではそれぞれのメリット・デメリットを部分的に抜粋します。&lt;br /&gt;
公平にするため、私情は入れず事実のみを載せます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cartfile.resolvedのみ
    &lt;ul&gt;
      &lt;li&gt;CIで毎回bootstrapでframework作成が必要&lt;/li&gt;
      &lt;li&gt;bootstrapが失敗するリスクがある&lt;/li&gt;
      &lt;li&gt;ライブラリ更新済みと未更新ブランチをまたぐとbootstrapが必要&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Cartfile.resolvedとCarthage
    &lt;ul&gt;
      &lt;li&gt;Swift versionを変更すると再生成が必要&lt;/li&gt;
      &lt;li&gt;Pull Requestでdiffが増える&lt;/li&gt;
      &lt;li&gt;git cloneが遅くなる&lt;/li&gt;
      &lt;li&gt;1ファイル100MBがあるとプッシュできない&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;swift-versionを変更すると再生成が必要&quot;&gt;Swift versionを変更すると再生成が必要&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Module Stability&lt;/code&gt;の有効になっていないライブラリでは、Swiftのバージョンを上げるたびにframeworkの再生成が必要です。&lt;/p&gt;

&lt;h3 id=&quot;ライブラリ更新後はbootstrapが必要&quot;&gt;ライブラリ更新後はbootstrapが必要&lt;/h3&gt;
&lt;p&gt;別メンバーがライブラリを更新したブランチをマージさせたら、&lt;br /&gt;
bootstrapでframework再生成が必要です。&lt;/p&gt;

&lt;h4 id=&quot;pull-requestでdiffが増える&quot;&gt;Pull Requestでdiffが増える&lt;/h4&gt;
&lt;p&gt;frameworkは1つのファイルではなくディレクトリになっており、中にファイルやディレクトリがあります。&lt;br /&gt;
そのファイル数だけGit管理となるため、frameworkを追加や変更したときのdiffは量が増えます。&lt;/p&gt;

&lt;h4 id=&quot;ciで毎回bootstrapでframework作成が必要&quot;&gt;CIで毎回bootstrapでframework作成が必要&lt;/h4&gt;
&lt;p&gt;CIなど新規環境下で環境構築をする場合は、bootstrapを実行してframeworkを生成する必要があります。&lt;br /&gt;
当然ですが、その分CI時間はかかります。&lt;/p&gt;

&lt;h4 id=&quot;bootstrapが失敗するリスクがある&quot;&gt;bootstrapが失敗するリスクがある&lt;/h4&gt;
&lt;p&gt;Carthageはxcodebuildでframeworkを生成しています。&lt;br /&gt;
可能性は低いのですが、私の環境でも何度か起きており、xcodebuildのバージョン差異や他要因で失敗することがあります。&lt;/p&gt;

&lt;p&gt;つまりそれは最悪Git管理下の情報だけでは環境再現が不可能となります。&lt;/p&gt;

&lt;h4 id=&quot;git-cloneが遅くなる&quot;&gt;git cloneが遅くなる&lt;/h4&gt;
&lt;p&gt;frameworkに関するファイル数が増える分、ファイル数やデータ数は増えるのでそれだけclone時やpull/fecthでのダウンロード時間は増えます。&lt;/p&gt;

&lt;h4 id=&quot;1ファイル100mbがあるとプッシュできない&quot;&gt;1ファイル100MBがあるとプッシュできない&lt;/h4&gt;
&lt;p&gt;GitHubでは1ファイル100MB以上のファイルコミットはできない制限が設けられており、LFSの設定が必要になります。&lt;/p&gt;

&lt;h2 id=&quot;私のチーム運用観点&quot;&gt;私のチーム運用観点&lt;/h2&gt;

&lt;p&gt;私が過去に経験してきたチームでのCarthage運用は次の通りです。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage/Build&lt;/code&gt;ディレクトリはコミットしない&lt;/li&gt;
  &lt;li&gt;Swiftバージョン更新時は、別ブランチからPull Request通す&lt;/li&gt;
  &lt;li&gt;Cartfileではバージョン指定してる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そして下記はそれぞれのメリット・デメリットに対する考えです。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Swift versionを変更すると再生成が必要
    &lt;ul&gt;
      &lt;li&gt;バージョン上がる度毎回変更してます&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ライブラリ更新後はbootstrapが必要
    &lt;ul&gt;
      &lt;li&gt;不要です。しかしGitからの取得量は増えます。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pull Requestでdiffが増える
    &lt;ul&gt;
      &lt;li&gt;バージョンを上げるだけのブランチなのでそもそもそのdiffを殆ど見ないです&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CIで毎回bootstrapでframework作成が必要
    &lt;ul&gt;
      &lt;li&gt;これはコミットしてるので不要です&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;bootstrapが失敗するリスクがある
    &lt;ul&gt;
      &lt;li&gt;バージョン固定してるので&lt;code class=&quot;highlighter-rouge&quot;&gt;bootstrap&lt;/code&gt;を使ってないです&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;git cloneが遅くなる
    &lt;ul&gt;
      &lt;li&gt;使っているfrmaeworkは10個ですが、それぞれのサイズは大きくはないので気になるほどになってないです&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;1ファイル100MBがあると運用不可能
    &lt;ul&gt;
      &lt;li&gt;使ってるframeworkに1ファイル100MBを超えるものはありません。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;バージョン上がるたびに全てのframework生成は時間がかかります。&lt;br /&gt;
それ以上に回数的にCIにかかる時間が増えます。&lt;br /&gt;
CIにキャッシュ仕込むのもありますが、CIが限定されますし、そのために開発環境が多少複雑にはなります。&lt;br /&gt;
git cloneが時間かかるとありますが、git cloneよりbootstrapの方が遥かに時間がかかります。&lt;br /&gt;
そして昔のCocoaPodsのように再現性がなくなることのリスクも気になります。&lt;/p&gt;

&lt;p&gt;なおこれは私の経験した案件にフィットした運用ですので鵜呑みにせず参考にしてください。&lt;/p&gt;

&lt;h2 id=&quot;もっと体系的に理解する&quot;&gt;もっと体系的に理解する&lt;/h2&gt;
&lt;p&gt;この記事では、記事の読みやすいよう導入に絞ってます。
もしCartfileの書き方や個別更新、インストール手順、CocoaPodsとの違いなど使い続けたら必要になる部分は別記事に分けており、&lt;br /&gt;
「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage&quot;&gt;Carthageの使い方を体系的に理解する&lt;/a&gt;&lt;/span&gt;
」からまとめて知ることができます。&lt;/p&gt;</content><author><name></name></author><category term="ios" /><category term="carthage" /><summary type="html">この記事ではcarthage bootstrapとは何か？Git管理はどうするか？をチーム運用観点でこれら関係性を整理します。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-15-ios-carthage-team-collaboration/0.png" /></entry><entry><title type="html">iOSのCarthage導入手順と注意点</title><link href="https://blog.mothule.com/ios/carthage/ios-carthage-install-guide" rel="alternate" type="text/html" title="iOSのCarthage導入手順と注意点" /><published>2020-05-14T00:00:00+09:00</published><updated>2020-05-19T00:52:14+09:00</updated><id>https://blog.mothule.com/ios/carthage/ios-carthage-install-guide</id><content type="html" xml:base="https://blog.mothule.com/ios/carthage/ios-carthage-install-guide">&lt;p&gt;Carthageの導入はちょっとした漏れでエラーにハマります。&lt;/p&gt;

&lt;p&gt;この記事は、iOSアプリにCarthage環境を導入する手順について説明します。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;MacにCarghageをインストールする&lt;/li&gt;
  &lt;li&gt;Cartfileにライブラリを記入&lt;/li&gt;
  &lt;li&gt;Cartfileからframework作成&lt;/li&gt;
  &lt;li&gt;プロジェクトにframeworkをリンク&lt;/li&gt;
  &lt;li&gt;ビルドフェイズにframeworkのコピースクリプトを作成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;なお、チーム運用、git管理、ライブラリのバージョン運用など詳細は、&lt;br /&gt;
「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage&quot;&gt;Carthageの使い方を体系的に理解する&lt;/a&gt;&lt;/span&gt;
」からまとめて知ることができます。&lt;/p&gt;

&lt;h2 id=&quot;macにcarghageをインストールする&quot;&gt;MacにCarghageをインストールする&lt;/h2&gt;

&lt;p&gt;CarthageはHomebrewでインストールできます。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew install carthage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Homebrewの使い方に関しては「&lt;span&gt;&lt;a href=&quot;/mac/homebrew/mac-homebrew-basic&quot;&gt;MacのHomebrewとは？仕組み・使い方と用語整理&lt;/a&gt;&lt;/span&gt;
」でまとめてあります。&lt;/p&gt;

&lt;h2 id=&quot;cartfileにライブラリを記入&quot;&gt;Cartfileにライブラリを記入&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile&lt;/code&gt;とはCarthageのライブラリ管理ファイルです。&lt;br /&gt;
テキストファイルになってて、&lt;br /&gt;
この中にCarthageで管理したいライブラリをまとめます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cartfileファイルの用意&lt;/li&gt;
  &lt;li&gt;Cartfileの編集&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cartfileファイルの用意&quot;&gt;Cartfileファイルの用意&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile&lt;/code&gt;はプロジェクト毎に用意できます。&lt;br /&gt;
対象プロジェクトのディレクトリ上に&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile&lt;/code&gt;を用意します。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~/your/xcode/project/path
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;touch Cartfile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;cartfile編集&quot;&gt;Cartfile編集&lt;/h3&gt;
&lt;p&gt;インストールしたいライブラリを&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile&lt;/code&gt;に記入します。&lt;br /&gt;
例えば&lt;a href=&quot;https://github.com/SwiftyJSON/SwiftyJSON&quot;&gt;SwiftyJSON&lt;/a&gt;であればに次のように記入します。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;github &quot;SwiftyJSON/SwiftyJSON&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;バージョン指定をしたい場合は「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage-cartfile-format&quot;&gt;CarthageのCartfileの書き方と個別更新方法&lt;/a&gt;&lt;/span&gt;
」に書き方をまとめてあります。&lt;/p&gt;

&lt;h2 id=&quot;cartfileからframework作成&quot;&gt;Cartfileからframework作成&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile&lt;/code&gt;の準備ができたら&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;コマンドでフレームワークを作成します。&lt;br /&gt;
オプションに&lt;code class=&quot;highlighter-rouge&quot;&gt;--platform&lt;/code&gt;と&lt;code class=&quot;highlighter-rouge&quot;&gt;--no-use-binaries&lt;/code&gt;をつけます。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;オプション&lt;/th&gt;
      &lt;th&gt;説明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;--platform&lt;/td&gt;
      &lt;td&gt;対象プラットフォーム指定。未指定は全環境のフレームワークを作成します&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;--no-use-binaries&lt;/td&gt;
      &lt;td&gt;予めビルドされたバイナリを使わずコードからビルドします&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;コマンドを実行するとframework作成処理が走ります。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;carthage update &lt;span class=&quot;nt&quot;&gt;--platform&lt;/span&gt; iOS &lt;span class=&quot;nt&quot;&gt;--no-use-binaries&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;***&lt;/span&gt; Fetching SwiftyJSON
&lt;span class=&quot;k&quot;&gt;***&lt;/span&gt; Checking out SwiftyJSON at &lt;span class=&quot;s2&quot;&gt;&quot;5.0.0&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;***&lt;/span&gt; xcodebuild output can be found &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; /var/folders/45/7f_wlrcs3xv6rmstcz2l5_000000gn/T/carthage-xcodebuild.IBF3eg.log
&lt;span class=&quot;k&quot;&gt;***&lt;/span&gt; Building scheme &lt;span class=&quot;s2&quot;&gt;&quot;SwiftyJSON iOS&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;SwiftyJSON.xcworkspace
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;成功すると&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage&lt;/code&gt;ディレクトリと&lt;code class=&quot;highlighter-rouge&quot;&gt;Cartfile.resolved&lt;/code&gt;ファイルが作成されます。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cartfile.resolved
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;で最終的な依存ライブラリ情報をまとめたテキストファイル&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Carthage
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;で作成されたライブラリのフレームワークが格納されたディレクトリ&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cartfile.resolvedの詳細については「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage-team-collaboration&quot;&gt;Carthage bootstrapとGit管理をチーム運用観点で整理&lt;/a&gt;&lt;/span&gt;
」でまとめてあります。&lt;/p&gt;

&lt;h2 id=&quot;プロジェクトにframeworkをリンク&quot;&gt;プロジェクトにframeworkをリンク&lt;/h2&gt;
&lt;p&gt;frameworkはプロジェクトにリンクしないと使えません。&lt;br /&gt;
プロジェクトの&lt;code class=&quot;highlighter-rouge&quot;&gt;Target &amp;gt; General &amp;gt; Linked frameworks and Libraries&lt;/code&gt;を ＋ ボタンを押してください。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/1.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/1.png&quot; width=&quot;100%&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;フレームワーク／ライブラリの選択画面が出るので、&lt;code class=&quot;highlighter-rouge&quot;&gt;Add Other...&lt;/code&gt; ボタンを押してください。
&lt;a href=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/2.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/2.png&quot; width=&quot;100%&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ここで先程作成したframeworkを指定します。&lt;br /&gt;
なおフレームワークは、&lt;code class=&quot;highlighter-rouge&quot;&gt;Carthage/Build/iOS&lt;/code&gt;ディレクトリの中にあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/3.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/3.png&quot; width=&quot;100%&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;frameworkを選ぶとXcodeプロジェクトに追加されます。&lt;br /&gt;
このとき&lt;strong&gt;Do Not Embed&lt;/strong&gt;になってることを確認してください。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/4.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/4.png&quot; width=&quot;100%&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これでプロジェクトにframeworkがリンクされて、&lt;br /&gt;
コード上のimportで対象frameworkを見つけられるようになります。&lt;/p&gt;

&lt;p&gt;なお、ボタンをポチポチせずにframeworkをドラッグ＆ドロップでも追加できます。&lt;/p&gt;

&lt;h3 id=&quot;注意embed-contentだとビルドエラーになる&quot;&gt;注意：Embed Contentだとビルドエラーになる&lt;/h3&gt;

&lt;p&gt;frameworkのリンク経路は、&lt;code class=&quot;highlighter-rouge&quot;&gt;Target &amp;gt; General&lt;/code&gt;と&lt;code class=&quot;highlighter-rouge&quot;&gt;Target &amp;gt; Build Phases&lt;/code&gt;の2つあり&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;General&lt;/code&gt;からframeworkを追加すると、デフォルトでは&lt;code class=&quot;highlighter-rouge&quot;&gt;Embed &amp;amp; Sign&lt;/code&gt;になります。&lt;br /&gt;
このままビルドすると次のようなビルドエラーが起きます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Multiple commands produce '.../YOUR-APP-NAME.app/Frameworks/&amp;lt;FRAMEWORK NAME&amp;gt;.framework':

1) Target '&amp;lt;YOUR TARGET NAME&amp;gt;' has copy command from
'/your/project/path/Carthage/Build/iOS/&amp;lt;FRAMEWORK NAME&amp;gt;.framework' to '.../YOUR-APP-NAME.app/Frameworks/&amp;lt;FRAMEWORK NAME&amp;gt;.framework'

2) That command depends on command in Target '&amp;lt;YOUR TARGET NAME&amp;gt;': script phase “Run Script”
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Embedded Frameworkではないので、&lt;code class=&quot;highlighter-rouge&quot;&gt;Do Not Embed&lt;/code&gt;に直してください。&lt;/p&gt;

&lt;h2 id=&quot;ビルドフェイズにフレームワークのコピースクリプトを作成&quot;&gt;ビルドフェイズにフレームワークのコピースクリプトを作成&lt;/h2&gt;
&lt;p&gt;リンクでビルドは通りますが、プロダクト内にframeworkが配置されていません。&lt;br /&gt;
&lt;strong&gt;ビルド時にframeworkをコピーするスクリプトを用意します。&lt;/strong&gt;&lt;br /&gt;
コピー処理は&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage copy-frameworks&lt;/code&gt;コマンドを使います。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ビルドフェイズにスクリプトフェイズ追加&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage copy-frameworks&lt;/code&gt;コマンドをセット&lt;/li&gt;
  &lt;li&gt;スクリプトの入力情報をセット&lt;/li&gt;
  &lt;li&gt;スクリプトの出力情報をセット&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1-ビルドフェイズにスクリプトフェイズ追加&quot;&gt;1. ビルドフェイズにスクリプトフェイズ追加&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Build Phases&lt;/code&gt;上の ＋ ボタンを押して&lt;code class=&quot;highlighter-rouge&quot;&gt;New Run Script Phase&lt;/code&gt;を選ぶと&lt;code class=&quot;highlighter-rouge&quot;&gt;Run Script&lt;/code&gt;フェイズが作成されます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/5.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/5.png&quot; width=&quot;100%&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-carthage-copy-frameworksコマンドをセット&quot;&gt;2. &lt;code class=&quot;highlighter-rouge&quot;&gt;carthage copy-frameworks&lt;/code&gt;コマンドをセット&lt;/h3&gt;
&lt;p&gt;Shellはシェルコマンドが呼べればいいので&lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/sh&lt;/code&gt;のままです。&lt;br /&gt;
スクリプト内で&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage copy-frameworks&lt;/code&gt;コマンドを追記します。&lt;br /&gt;
絶対パスでも相対パスでもパスが通っていればどちらでも大丈夫です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/6.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/6.png&quot; width=&quot;100%&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-スクリプトの入力情報をセット&quot;&gt;3. スクリプトの入力情報をセット&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage copy-frameworks&lt;/code&gt;はframeworkのパスを渡すと、ビルド対象プロジェクト内にコピーします。&lt;br /&gt;
厳密には&lt;code class=&quot;highlighter-rouge&quot;&gt;$BUILD_PRODUCTS_DIR/$FRAMEWORKS_FOLDER_PATH&lt;/code&gt;パスにコピーします。&lt;a href=&quot;https://github.com/Carthage/Carthage/blob/f656edfe35651b54eec50d814e79d079f8eea7c4/Source/carthage/CopyFrameworks.swift#L25&quot;&gt;GitHub/Carthage&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/7.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/7.png&quot; width=&quot;100%&quot; alt=&quot;Carthage Xcode Build Phases Run Script Input Files&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-スクリプトの出力情報をセット&quot;&gt;4. スクリプトの出力情報をセット&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Output Files&lt;/code&gt;はコピー先を指定します。&lt;/p&gt;

&lt;p&gt;実は&lt;code class=&quot;highlighter-rouge&quot;&gt;Output Files&lt;/code&gt;は指定せずとも動作に問題はありません。&lt;strong&gt;しかしビルドパフォーマンスに影響します。&lt;/strong&gt;&lt;br /&gt;
詳しくは「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage-measure-copy-speed-with-output-files&quot;&gt;CarthageのビルドフェイズでOutput Files指定による速度調査&lt;/a&gt;&lt;/span&gt;
」に調査結果をまとめてあります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/8.png&quot;&gt;&lt;img src=&quot;/assets/images/2020-05-14-ios-carthage-install-guide/8.png&quot; width=&quot;100%&quot; alt=&quot;Carthage Xcode Build Phases Run Script Output Files&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;注意-carthage-copy-frameworksを忘れるとランタイムエラー&quot;&gt;注意: carthage copy-frameworksを忘れるとランタイムエラー&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage copy-frameworks&lt;/code&gt;コマンドを実行しなくてもビルドは通ります。&lt;br /&gt;
しかし実行すると次のようなにライブラリのロードエラーが起きます。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dyld: Library not loaded: @rpath/SwiftyJSON.framework/SwiftyJSON
  Referenced from: /Users/mothule/Library/Developer/CoreSimulator/Devices/1DB7E7C4-D7CD-44BA-B3F9-F66DC4E5EC51/data/Containers/Bundle/Application/6B0FDFCC-9D12-47D5-9B74-B837BE8FC983/UseCarthage.app/UseCarthage
  Reason: image not found
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;これはプロダクト内にframeworkが配置されてないことで、&lt;br /&gt;
実行環境にプロダクトがインストールされてもframeworkが見つからずdyldがランタイムエラーを起こすためです。&lt;/p&gt;

&lt;h3 id=&quot;注意-input-filesで渡すframeworkのパスを間違えるとビルドエラー&quot;&gt;注意: Input Filesで渡すframeworkのパスを間違えるとビルドエラー&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage copy-frameworks&lt;/code&gt;コマンドに渡すframeworkのパスが間違っているとビルドエラーが発生します。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Input Files&lt;/code&gt;または&lt;code class=&quot;highlighter-rouge&quot;&gt;Input File Lists&lt;/code&gt;で渡してるframeworkのパスが正しいか確認してください。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Could not find framework &quot;&amp;lt;framework name&amp;gt;&quot; at path &amp;lt;wrong framework path&amp;gt;.
Ensure that the given path is appropriately entered and that your &quot;Input Files&quot; and &quot;Input File Lists&quot; have been entered correctly.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;フレームワークのパスはまとめて指定も可能&quot;&gt;フレームワークのパスはまとめて指定も可能&lt;/h3&gt;

&lt;p&gt;Input Filesに各フレームワークのパスをセットしなくても、xcfilelistという拡張子で指定することで一律管理も可能です。
詳細は「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage-use-xcfilelist&quot;&gt;CarthageでInput File Listsにxcfilelistを渡す利点と方法&lt;/a&gt;&lt;/span&gt;
」にまとめてあります。&lt;/p&gt;

&lt;h2 id=&quot;ライブラリを追加する&quot;&gt;ライブラリを追加する&lt;/h2&gt;
&lt;p&gt;新しくframeworkを追加や更新する場合は、&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage copy-frameworks&lt;/code&gt;コマンドの登録以外の作業をやります。&lt;br /&gt;
また&lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt;にオプションが一つ増えます&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Cartfileにライブラリ追加&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;でライブラリ個別更新&lt;/li&gt;
  &lt;li&gt;リンクにframeworkを追加&lt;/li&gt;
  &lt;li&gt;コピースクリプトのInput FilesとOutput Filesに追加&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新しくビルドフェイズにスクリプトを追加はしません。&lt;/p&gt;

&lt;h3 id=&quot;carthage-updateでライブラリ個別更新&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;でライブラリ個別更新&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;とするとCartfileにかかれている全てのライブラリが対象となります。&lt;br /&gt;
他のライブラリのバージョンは更新せず追加したライブラリだけのframework作成をしたい場合は、&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;carthage update&lt;/code&gt;にライブラリ名を渡します。&lt;/p&gt;

&lt;p&gt;例えば新しく追加したライブラリが&lt;code class=&quot;highlighter-rouge&quot;&gt;SDWebImage&lt;/code&gt;であれば、コマンドラインは次のようになります。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;carthage update &lt;span class=&quot;nt&quot;&gt;--platform&lt;/span&gt; iOS &lt;span class=&quot;nt&quot;&gt;--no-use-binaries&lt;/span&gt; SDWebImage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;これで既存ライブラリは更新されません。&lt;/p&gt;

&lt;h2 id=&quot;もっと体系的に理解する&quot;&gt;もっと体系的に理解する&lt;/h2&gt;

&lt;p&gt;この記事では、記事の読みやすいよう導入に絞ってます。
もしチーム運用、git管理、ライブラリのバージョン運用など使い続けたら必要になる部分は別記事に分けており、&lt;br /&gt;
「&lt;span&gt;&lt;a href=&quot;/ios/carthage/ios-carthage&quot;&gt;Carthageの使い方を体系的に理解する&lt;/a&gt;&lt;/span&gt;
」からまとめて知ることができます。&lt;/p&gt;</content><author><name></name></author><category term="ios" /><category term="carthage" /><summary type="html">Carthageの導入はちょっとした漏れでエラーにハマります。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blog.mothule.com/assets/images/2020-05-14-ios-carthage-install-guide/eyecatch.png" /></entry></feed>